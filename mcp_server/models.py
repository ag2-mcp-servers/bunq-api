# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T17:46:12+00:00

from __future__ import annotations

from typing import List, Optional

from pydantic import BaseModel, Field, RootModel


class Address(BaseModel):
    city: Optional[str] = Field(None, description='The city.')
    country: Optional[str] = Field(
        None, description='The country as an ISO 3166-1 alpha-2 country code.'
    )
    extra: Optional[str] = Field(
        None,
        description='The apartment, building or other extra information for addresses.',
    )
    house_number: Optional[str] = Field(None, description='The house number.')
    is_user_address_updated: Optional[bool] = Field(
        None,
        description='To show whether user created or updated her address for app event listing.',
    )
    mailbox_name: Optional[str] = Field(
        None, description='The name on the mailbox (only used for Postal addresses).'
    )
    po_box: Optional[str] = Field(None, description='The PO box.')
    postal_code: Optional[str] = Field(None, description='The postal code.')
    province: Optional[str] = Field(
        None, description='The province according to local standard.'
    )
    street: Optional[str] = Field(None, description='The street.')


class Amount(BaseModel):
    currency: Optional[str] = Field(
        None,
        description='The currency of the amount. It is an ISO 4217 formatted currency code.',
    )
    value: Optional[str] = Field(
        None, description='The amount formatted to two decimal places.'
    )


class AttachmentConversationContentListing(BaseModel):
    pass


class AttachmentMasterCardActionRefund(BaseModel):
    id: Optional[int] = Field(None, description='The id of the attached Attachment.')


class AttachmentMonetaryAccount(BaseModel):
    pass


class AttachmentMonetaryAccountContentListing(BaseModel):
    pass


class AttachmentMonetaryAccountCreate(BaseModel):
    id: Optional[int] = Field(None, description='The ID of the attachment created.')


class AttachmentMonetaryAccountPayment(BaseModel):
    id: Optional[int] = Field(None, description='The id of the attached Attachment.')
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the MonetaryAccount this Attachment is attached from.',
    )


class AttachmentPublic(BaseModel):
    pass


class AttachmentPublicContentListing(BaseModel):
    pass


class AttachmentUrl(BaseModel):
    type: Optional[str] = Field(None, description='The file type of attachment.')
    url: Optional[str] = Field(
        None, description='The URL where the attachment can be downloaded.'
    )


class AttachmentUserContentListing(BaseModel):
    pass


class AvatarCreate(BaseModel):
    uuid: Optional[str] = Field(None, description='The UUID of the created avatar.')


class BillingContractSubscription(BaseModel):
    contract_date_end: Optional[str] = Field(
        None, description='The date until when the billing contract is valid.'
    )
    contract_date_start: Optional[str] = Field(
        None, description='The date from when the billing contract is valid.'
    )
    contract_version: Optional[int] = Field(
        None, description='The version of the billing contract.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the billing contract was made.'
    )
    id: Optional[int] = Field(None, description='The id of the billing contract.')
    status: Optional[str] = Field(None, description='The subscription status.')
    sub_status: Optional[str] = Field(None, description='The subscription substatus.')
    subscription_type: Optional[str] = Field(
        None,
        description='The subscription type of the user. Can be one of PERSON_SUPER_LIGHT_V1, PERSON_LIGHT_V1, PERSON_MORE_V1, PERSON_FREE_V1, PERSON_PREMIUM_V1, COMPANY_V1, or COMPANY_V2.',
    )
    subscription_type_downgrade: Optional[str] = Field(
        None,
        description='The subscription type the user will have after a subscription downgrade. Will be null if downgrading is not possible.',
    )
    updated: Optional[str] = Field(
        None, description='The timestamp when the billing contract was last updated.'
    )


class BillingContractSubscriptionListing(BaseModel):
    contract_date_end: Optional[str] = Field(
        None, description='The date until when the billing contract is valid.'
    )
    contract_date_start: Optional[str] = Field(
        None, description='The date from when the billing contract is valid.'
    )
    contract_version: Optional[int] = Field(
        None, description='The version of the billing contract.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the billing contract was made.'
    )
    id: Optional[int] = Field(None, description='The id of the billing contract.')
    status: Optional[str] = Field(None, description='The subscription status.')
    sub_status: Optional[str] = Field(None, description='The subscription substatus.')
    subscription_type: Optional[str] = Field(
        None,
        description='The subscription type of the user. Can be one of PERSON_SUPER_LIGHT_V1, PERSON_LIGHT_V1, PERSON_MORE_V1, PERSON_FREE_V1, PERSON_PREMIUM_V1, COMPANY_V1, or COMPANY_V2.',
    )
    subscription_type_downgrade: Optional[str] = Field(
        None,
        description='The subscription type the user will have after a subscription downgrade. Will be null if downgrading is not possible.',
    )
    updated: Optional[str] = Field(
        None, description='The timestamp when the billing contract was last updated.'
    )


class BirdeeInvestmentPortfolioBalance(BaseModel):
    amount_available: Optional[Amount] = Field(
        None,
        description='The current valuation of the portfolio, minus any amount pending withdrawal.',
    )
    amount_deposit_pending: Optional[Amount] = Field(
        None,
        description="The amount that's sent to Birdee, but pending investment on the portfolio.",
    )
    amount_deposit_total: Optional[Amount] = Field(
        None, description='The total amount deposited.'
    )
    amount_fee_total: Optional[Amount] = Field(
        None, description='The total fee amount.'
    )
    amount_profit: Optional[Amount] = Field(
        None,
        description='The difference between the netto deposited amount and the current valuation.',
    )
    amount_withdrawal_pending: Optional[Amount] = Field(
        None, description="The amount that's sent to Birdee, but pending withdrawal."
    )
    amount_withdrawal_total: Optional[Amount] = Field(
        None, description='The total amount withdrawn.'
    )


class BirdeeInvestmentPortfolioGoal(BaseModel):
    amount_target: Optional[Amount] = Field(
        None, description='The investment goal amount.'
    )
    time_end: Optional[str] = Field(None, description='The investment goal end time.')


class BirdeePortfolioAllocation(BaseModel):
    amount: Optional[str] = Field(
        None,
        description='Monetary amount of the financial instrument in the portfolio.',
    )
    instrument_asset_class: Optional[str] = Field(
        None, description='Asset Class of the instrument.'
    )
    instrument_asset_class_name: Optional[str] = Field(
        None, description='Name of the asset class.'
    )
    instrument_currency: Optional[str] = Field(
        None, description='Currency of the instrument.'
    )
    instrument_isin: Optional[str] = Field(
        None, description='ISIN code of the instrument.'
    )
    instrument_key_information_document_uri: Optional[str] = Field(
        None, description='Key Information Document of the instrument.'
    )
    instrument_name: Optional[str] = Field(None, description='Name of the instrument.')
    instrument_region_name: Optional[str] = Field(
        None, description='Name of the geographical region covered by the instrument'
    )
    price: Optional[str] = Field(
        None, description='Unit price of the financial instrument.'
    )
    quantity: Optional[str] = Field(
        None, description='Quantity of the financial instrument in the portfolio.'
    )
    weight: Optional[str] = Field(
        None, description='Weight of the financial instrument in the model portfolio.'
    )


class BunqId(BaseModel):
    id: Optional[int] = Field(
        None, description='An integer ID of an object. Unique per object type.'
    )


class BunqMeMerchantAvailable(BaseModel):
    available: Optional[bool] = Field(
        None, description='Whether or not the merchant is available for the user.'
    )
    merchant_type: Optional[str] = Field(
        None, description='A merchant type supported by bunq.me.'
    )


class BunqMeTabCreate(BaseModel):
    id: Optional[int] = Field(None, description='The id of the created bunq.me.')


class BunqMeTabUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CardBatchCreate(BaseModel):
    updated_card_ids: Optional[List[BunqId]] = Field(
        None, description='The ids of the cards that have been updated.'
    )


class CardBatchReplaceCreate(BaseModel):
    updated_card_ids: Optional[List[BunqId]] = Field(
        None, description='The ids of the cards that have been replaced.'
    )


class CardCountryPermission(BaseModel):
    country: Optional[str] = Field(
        None, description='The country to allow transactions in (e.g. NL, DE).'
    )
    expiry_time: Optional[str] = Field(None, description='Expiry time of this rule.')
    id: Optional[int] = Field(
        None, description='The id of the card country permission entry.'
    )


class CardCreditCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CardDebitCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CardGeneratedCvc2(BaseModel):
    type: Optional[str] = Field(
        None, description='The type of generated cvc2. Can be STATIC or GENERATED.'
    )


class CardGeneratedCvc2Create(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CardGeneratedCvc2Listing(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the cvc code's creation."
    )
    cvc2: Optional[str] = Field(None, description='The cvc2 code.')
    expiry_time: Optional[str] = Field(None, description='Expiry time of the cvc2.')
    id: Optional[int] = Field(None, description='The id of the cvc code.')
    status: Optional[str] = Field(
        None,
        description='The status of the cvc2. Can be AVAILABLE, USED, EXPIRED, BLOCKED.',
    )
    type: Optional[str] = Field(
        None, description='The type of generated cvc2. Can be STATIC or GENERATED.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the cvc code's last update."
    )


class CardGeneratedCvc2Read(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the cvc code's creation."
    )
    cvc2: Optional[str] = Field(None, description='The cvc2 code.')
    expiry_time: Optional[str] = Field(None, description='Expiry time of the cvc2.')
    id: Optional[int] = Field(None, description='The id of the cvc code.')
    status: Optional[str] = Field(
        None,
        description='The status of the cvc2. Can be AVAILABLE, USED, EXPIRED, BLOCKED.',
    )
    type: Optional[str] = Field(
        None, description='The type of generated cvc2. Can be STATIC or GENERATED.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the cvc code's last update."
    )


class CardGeneratedCvc2Update(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CardNameListing(BaseModel):
    possible_card_name_array: Optional[List[str]] = Field(
        None,
        description="All possible variations (of suitable length) of user's legal name for the debit card.",
    )


class CardPinAssignment(BaseModel):
    monetary_account_id: Optional[int] = Field(
        None,
        description='The ID of the monetary account to assign to this pin for the card.',
    )
    pin_code: Optional[str] = Field(
        None, description='The 4 digit PIN to be assigned to this account.'
    )
    routing_type: Optional[str] = Field(
        None, description='Routing type. Can be MANUAL or AUTOMATIC'
    )
    type: Optional[str] = Field(
        None, description='PIN type. Can be PRIMARY, SECONDARY or TERTIARY'
    )


class CardPrimaryAccountNumber(BaseModel):
    description: Optional[str] = Field(
        None, description='The description for this PAN.'
    )
    four_digit: Optional[str] = Field(
        None, description='The last four digits of the PAN.'
    )
    id: Optional[int] = Field(None, description='The ID for this Virtual PAN.')
    monetary_account_id: Optional[int] = Field(
        None,
        description='The ID of the monetary account to assign to this PAN, only for Online Cards.',
    )
    status: Optional[str] = Field(
        None, description='The status for this PAN, only for Online Cards.'
    )
    uuid: Optional[str] = Field(None, description='The UUID for this Virtual PAN.')


class CardReplace(BaseModel):
    name_on_card: Optional[str] = Field(
        None,
        description="The user's name as it will be on the card. Check 'card-name' for the available card names for a user.",
    )
    pin_code_assignment: Optional[List[CardPinAssignment]] = Field(
        None, description='Array of Types, PINs, account IDs assigned to the card.'
    )
    preferred_name_on_card: Optional[str] = Field(
        None, description="The user's preferred name that can be put on the card."
    )
    second_line: Optional[str] = Field(None, description='The second line on the card.')


class CardReplaceCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CardUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class Certificate(BaseModel):
    certificate: Optional[str] = Field(
        None, description='A single certificate in the chain in .PEM format.'
    )


class CertificatePinned(BaseModel):
    certificate_chain: List[Certificate] = Field(
        ..., description='The certificate chain in .PEM format.'
    )


class CertificatePinnedCreate(BaseModel):
    id: Optional[int] = Field(
        None, description='The id generated for the pinned certificate chain.'
    )


class CertificatePinnedDelete(BaseModel):
    pass


class CertificatePinnedListing(BaseModel):
    certificate_chain: Optional[str] = Field(
        None,
        description='The certificate chain in .PEM format. Certificates are glued with newline characters.',
    )
    id: Optional[int] = Field(
        None, description='The id generated for the pinned certificate chain.'
    )


class CertificatePinnedRead(BaseModel):
    certificate_chain: Optional[str] = Field(
        None,
        description='The certificate chain in .PEM format. Certificates are glued with newline characters.',
    )
    id: Optional[int] = Field(
        None, description='The id generated for the pinned certificate chain.'
    )


class CompanyCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CompanyUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CompanyVatNumber(BaseModel):
    country: Optional[str] = Field(
        None, description='The country of the VAT identification number.'
    )
    value: Optional[str] = Field(
        None, description='The VAT identification number number.'
    )


class ConfirmationOfFundsCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CurrencyCloudBeneficiary(BaseModel):
    all_field: List[str] = Field(
        ...,
        description='All fields that were required by CurrencyCloud. Obtained through the CurrencyCloudBeneficiaryRequirement listing.',
    )
    country: str = Field(..., description='The country of the beneficiary.')
    currency: str = Field(..., description='The currency of the beneficiary.')
    legal_entity_type: str = Field(
        ..., description='The legal entity type of the beneficiary.'
    )
    name: str = Field(..., description='The name of the beneficiary.')
    payment_type: str = Field(
        ..., description='The payment type this requirement is for.'
    )


class CurrencyCloudBeneficiaryCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CurrencyCloudBeneficiaryListing(BaseModel):
    account_number: Optional[str] = Field(
        None, description='The account number to display for the beneficiary.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp of the beneficiaries creation.'
    )
    currency: Optional[str] = Field(
        None, description='The currency of the beneficiary.'
    )
    external_identifier: Optional[str] = Field(
        None, description='The external identifier of the beneficiary.'
    )
    id: Optional[int] = Field(None, description='The id of the profile.')
    name: Optional[str] = Field(None, description='The name of the beneficiary.')
    updated: Optional[str] = Field(
        None, description='The timestamp of the beneficiaries last update.'
    )


class CurrencyCloudBeneficiaryRead(BaseModel):
    account_number: Optional[str] = Field(
        None, description='The account number to display for the beneficiary.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp of the beneficiaries creation.'
    )
    currency: Optional[str] = Field(
        None, description='The currency of the beneficiary.'
    )
    external_identifier: Optional[str] = Field(
        None, description='The external identifier of the beneficiary.'
    )
    id: Optional[int] = Field(None, description='The id of the profile.')
    name: Optional[str] = Field(None, description='The name of the beneficiary.')
    updated: Optional[str] = Field(
        None, description='The timestamp of the beneficiaries last update.'
    )


class CurrencyCloudBeneficiaryRequirementField(BaseModel):
    input_type: Optional[str] = Field(
        None,
        description='The type of data to input. Determines the keyboard to display.',
    )
    label: Optional[str] = Field(
        None, description='The label to display for the field.'
    )
    name: Optional[str] = Field(None, description='The name of the field.')
    validation_expression: Optional[str] = Field(
        None, description='The expression to validate field input.'
    )


class CurrencyCloudBeneficiaryRequirementListing(BaseModel):
    all_field: Optional[List[CurrencyCloudBeneficiaryRequirementField]] = Field(
        None, description='The fields that are required.'
    )
    legal_entity_type: Optional[str] = Field(
        None, description='The entity type this requirement is for.'
    )
    payment_type: Optional[str] = Field(
        None, description='The payment type this requirement is for.'
    )


class CurrencyCloudPaymentQuoteCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CurrencyConversionQuoteCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class CurrencyConversionQuoteRead(BaseModel):
    amount_source: Optional[Amount] = Field(None, description='The amount to convert.')
    amount_target: Optional[Amount] = Field(
        None, description='The amount to convert to.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the quote's creation."
    )
    id: Optional[int] = Field(None, description='The id of the quote.')
    rate: Optional[str] = Field(None, description='The conversion rate.')
    status: Optional[str] = Field(None, description='The status of the quote.')
    time_expiry: Optional[str] = Field(
        None,
        description='Timestamp for when this quote expires and the user should request a new one.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the quote's last update."
    )


class CurrencyConversionQuoteUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class Customer(BaseModel):
    billing_account_id: Optional[str] = Field(
        None, description="The primary billing account account's id."
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the customer object's creation."
    )
    id: Optional[int] = Field(None, description='The id of the customer.')
    invoice_notification_preference: Optional[str] = Field(
        None, description='The preferred notification type for invoices.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the customer object's last update."
    )


class CustomerLimit(BaseModel):
    limit_amount_monthly: Optional[Amount] = Field(
        None, description='The maximum amount a user is allowed to spend in a month.'
    )
    limit_card_debit_maestro: Optional[int] = Field(
        None, description='The limit of Maestro cards.'
    )
    limit_card_debit_mastercard: Optional[int] = Field(
        None, description='The limit of MasterCard cards.'
    )
    limit_card_debit_wildcard: Optional[int] = Field(
        None,
        description='DEPRECTATED: The limit of wildcards, e.g. Maestro or MasterCard cards.',
    )
    limit_card_replacement: Optional[int] = Field(
        None, description='The limit of free replacement cards.'
    )
    limit_card_wildcard: Optional[int] = Field(
        None, description='The limit of wildcards, e.g. Maestro or MasterCard cards.'
    )
    limit_monetary_account: Optional[int] = Field(
        None, description='The limit of monetary accounts.'
    )
    limit_monetary_account_remaining: Optional[int] = Field(
        None, description='The amount of additional monetary accounts you can create.'
    )
    spent_amount_monthly: Optional[Amount] = Field(
        None, description='The amount the user has spent in the last month.'
    )


class CustomerLimitListing(BaseModel):
    limit_amount_monthly: Optional[Amount] = Field(
        None, description='The maximum amount a user is allowed to spend in a month.'
    )
    limit_card_debit_maestro: Optional[int] = Field(
        None, description='The limit of Maestro cards.'
    )
    limit_card_debit_mastercard: Optional[int] = Field(
        None, description='The limit of MasterCard cards.'
    )
    limit_card_debit_wildcard: Optional[int] = Field(
        None,
        description='DEPRECTATED: The limit of wildcards, e.g. Maestro or MasterCard cards.',
    )
    limit_card_replacement: Optional[int] = Field(
        None, description='The limit of free replacement cards.'
    )
    limit_card_wildcard: Optional[int] = Field(
        None, description='The limit of wildcards, e.g. Maestro or MasterCard cards.'
    )
    limit_monetary_account: Optional[int] = Field(
        None, description='The limit of monetary accounts.'
    )
    limit_monetary_account_remaining: Optional[int] = Field(
        None, description='The amount of additional monetary accounts you can create.'
    )
    spent_amount_monthly: Optional[Amount] = Field(
        None, description='The amount the user has spent in the last month.'
    )


class DeviceServer(BaseModel):
    description: str = Field(
        ...,
        description='The description of the DeviceServer. This is only for your own reference when reading the DeviceServer again.',
    )
    permitted_ips: Optional[List[str]] = Field(
        None,
        description='An array of IPs (v4 or v6) this DeviceServer will be able to do calls from. These will be linked to the API key.',
    )
    secret: str = Field(
        ..., description='The API key. You can request an API key in the bunq app.'
    )


class DeviceServerCreate(BaseModel):
    id: Optional[int] = Field(
        None, description='The id of the DeviceServer as created on the server.'
    )


class DeviceServerListing(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the DeviceServer's creation."
    )
    description: Optional[str] = Field(
        None, description='The description of the DeviceServer.'
    )
    id: Optional[int] = Field(
        None, description='The id of the DeviceServer as created on the server.'
    )
    ip: Optional[str] = Field(
        None, description='The ip address which was used to create the DeviceServer.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the DeviceServer. Can be ACTIVE, BLOCKED, NEEDS_CONFIRMATION or OBSOLETE.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the DeviceServer's last update."
    )


class DeviceServerRead(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the DeviceServer's creation."
    )
    description: Optional[str] = Field(
        None, description='The description of the DeviceServer.'
    )
    id: Optional[int] = Field(
        None, description='The id of the DeviceServer as created on the server.'
    )
    ip: Optional[str] = Field(
        None, description='The ip address which was used to create the DeviceServer.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the DeviceServer. Can be ACTIVE, BLOCKED, NEEDS_CONFIRMATION or OBSOLETE.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the DeviceServer's last update."
    )


class DraftPaymentCreate(BaseModel):
    id: Optional[int] = Field(None, description='The id of the created DrafPayment.')


class DraftPaymentUpdate(BaseModel):
    id: Optional[int] = Field(None, description='The id of the created DrafPayment.')


class ErrorItem(BaseModel):
    error_description: Optional[str] = Field(
        None, description='The error description in English.'
    )
    error_description_translated: Optional[str] = Field(
        None, description="The error description translated to the user's language."
    )


class Error(RootModel[List[ErrorItem]]):
    root: List[ErrorItem]


class ExportAnnualOverview(BaseModel):
    year: int = Field(..., description='The year for which the overview is.')


class ExportAnnualOverviewContentListing(BaseModel):
    pass


class ExportAnnualOverviewCreate(BaseModel):
    id: Optional[int] = Field(
        None, description='The id of the annual overview as created on the server.'
    )


class ExportAnnualOverviewDelete(BaseModel):
    pass


class ExportRib(BaseModel):
    pass


class ExportRibContentListing(BaseModel):
    pass


class ExportRibCreate(BaseModel):
    id: Optional[int] = Field(
        None, description='The id of the rib as created on the server.'
    )


class ExportRibDelete(BaseModel):
    pass


class ExportRibListing(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the RIB's creation."
    )
    id: Optional[int] = Field(
        None, description='The id of the rib as created on the server.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the RIB's last update."
    )


class ExportRibRead(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the RIB's creation."
    )
    id: Optional[int] = Field(
        None, description='The id of the rib as created on the server.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the RIB's last update."
    )


class ExportStatement(BaseModel):
    date_end: str = Field(..., description='The end date for making statements.')
    date_start: str = Field(..., description='The start date for making statements.')
    include_attachment: Optional[bool] = Field(
        None,
        description='Only for PDF exports. Includes attachments to mutations in the export, such as scanned receipts.',
    )
    regional_format: Optional[str] = Field(
        None,
        description='Required for CSV exports. The regional format of the statement, can be UK_US (comma-separated) or EUROPEAN (semicolon-separated).',
    )
    statement_format: str = Field(
        ...,
        description='The format type of statement. Allowed values: MT940, CSV, PDF.',
    )


class ExportStatementCardContentListing(BaseModel):
    pass


class ExportStatementCardCsv(BaseModel):
    date_end: str = Field(..., description='The end date for making statements.')
    date_start: str = Field(..., description='The start date for making statements.')
    regional_format: str = Field(
        ...,
        description='Required for CSV exports. The regional format of the statement, can be UK_US (comma-separated) or EUROPEAN (semicolon-separated).',
    )


class ExportStatementCardCsvCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class ExportStatementCardCsvDelete(BaseModel):
    pass


class ExportStatementCardCsvListing(BaseModel):
    card_id: Optional[int] = Field(
        None, description='The card for which this statement was created.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    date_end: Optional[str] = Field(
        None, description='The date until which statement shows transactions.'
    )
    date_start: Optional[str] = Field(
        None, description='The date from when this statement shows transactions.'
    )
    id: Optional[int] = Field(
        None, description='The id of the customer statement model.'
    )
    regional_format: Optional[str] = Field(
        None, description='The regional format of a CSV statement.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class ExportStatementCardCsvRead(BaseModel):
    card_id: Optional[int] = Field(
        None, description='The card for which this statement was created.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    date_end: Optional[str] = Field(
        None, description='The date until which statement shows transactions.'
    )
    date_start: Optional[str] = Field(
        None, description='The date from when this statement shows transactions.'
    )
    id: Optional[int] = Field(
        None, description='The id of the customer statement model.'
    )
    regional_format: Optional[str] = Field(
        None, description='The regional format of a CSV statement.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class ExportStatementCardListing(BaseModel):
    card_id: Optional[int] = Field(
        None, description='The card for which this statement was created.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    date_end: Optional[str] = Field(
        None, description='The date until which statement shows transactions.'
    )
    date_start: Optional[str] = Field(
        None, description='The date from when this statement shows transactions.'
    )
    id: Optional[int] = Field(
        None, description='The id of the customer statement model.'
    )
    regional_format: Optional[str] = Field(
        None, description='The regional format of a CSV statement.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class ExportStatementCardPdf(BaseModel):
    date_end: str = Field(..., description='The end date for making statements.')
    date_start: str = Field(..., description='The start date for making statements.')


class ExportStatementCardPdfCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class ExportStatementCardPdfDelete(BaseModel):
    pass


class ExportStatementCardPdfListing(BaseModel):
    card_id: Optional[int] = Field(
        None, description='The card for which this statement was created.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    date_end: Optional[str] = Field(
        None, description='The date until which statement shows transactions.'
    )
    date_start: Optional[str] = Field(
        None, description='The date from when this statement shows transactions.'
    )
    id: Optional[int] = Field(
        None, description='The id of the customer statement model.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class ExportStatementCardPdfRead(BaseModel):
    card_id: Optional[int] = Field(
        None, description='The card for which this statement was created.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    date_end: Optional[str] = Field(
        None, description='The date until which statement shows transactions.'
    )
    date_start: Optional[str] = Field(
        None, description='The date from when this statement shows transactions.'
    )
    id: Optional[int] = Field(
        None, description='The id of the customer statement model.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class ExportStatementCardRead(BaseModel):
    card_id: Optional[int] = Field(
        None, description='The card for which this statement was created.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    date_end: Optional[str] = Field(
        None, description='The date until which statement shows transactions.'
    )
    date_start: Optional[str] = Field(
        None, description='The date from when this statement shows transactions.'
    )
    id: Optional[int] = Field(
        None, description='The id of the customer statement model.'
    )
    regional_format: Optional[str] = Field(
        None, description='The regional format of a CSV statement.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class ExportStatementContentListing(BaseModel):
    pass


class ExportStatementCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class ExportStatementDelete(BaseModel):
    pass


class ExportStatementPayment(BaseModel):
    pass


class ExportStatementPaymentContentListing(BaseModel):
    pass


class ExportStatementPaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class ExportStatementPaymentRead(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    id: Optional[int] = Field(
        None, description='The id of the single payment statement model.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class Geolocation(BaseModel):
    altitude: Optional[int] = Field(
        None, description='The altitude for a geolocation restriction.'
    )
    latitude: Optional[int] = Field(
        None, description='The latitude for a geolocation restriction.'
    )
    longitude: Optional[int] = Field(
        None, description='The longitude for a geolocation restriction.'
    )
    radius: Optional[int] = Field(
        None, description='The radius for a geolocation restriction.'
    )


class IdealMerchantTransactionCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class Image(BaseModel):
    attachment_public_uuid: Optional[str] = Field(
        None,
        description='The public UUID of the public attachment containing the image.',
    )
    content_type: Optional[str] = Field(
        None, description='The content-type as a MIME filetype.'
    )
    height: Optional[int] = Field(None, description='The image height in pixels.')
    width: Optional[int] = Field(None, description='The image width in pixels.')


class InsightListing(BaseModel):
    amount_total: Optional[Amount] = Field(
        None, description='The total amount of the transactions in the category.'
    )
    category: Optional[str] = Field(None, description='The category.')
    category_translated: Optional[str] = Field(
        None, description='The translated category.'
    )
    number_of_transactions: Optional[int] = Field(
        None, description='The number of the transactions in the category.'
    )


class InsightPreferenceDateListing(BaseModel):
    day_of_month: Optional[int] = Field(
        None, description='The day of month at which budgeting/insights should start.'
    )


class Installation(BaseModel):
    client_public_key: str = Field(
        ...,
        description='Your public key. This is the public part of the key pair that you are going to use to create value of the "X-Bunq-Client-Signature" header for all future API calls.',
    )


class InstallationListing(BaseModel):
    id: Optional[int] = Field(
        None,
        description="The id of the Installation as created on the server. You can use this id to request the server's public key again.",
    )


class InstallationRead(BaseModel):
    id: Optional[int] = Field(
        None,
        description="The id of the Installation as created on the server. You can use this id to request the server's public key again.",
    )


class InstallationServerPublicKey(BaseModel):
    server_public_key: Optional[str] = Field(
        None,
        description='The server\'s public key for this Installation. You should use this key to verify the "X-Bunq-Server-Signature" header for each response from the server.',
    )


class InstallationServerPublicKeyListing(BaseModel):
    server_public_key: Optional[str] = Field(
        None, description="The server's public key for this Installation."
    )


class InstallationToken(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the Token's creation."
    )
    id: Optional[int] = Field(None, description='The id of the Token.')
    token: Optional[str] = Field(
        None,
        description='The installation token is the token the client has to provide in the "X-Bunq-Client-Authentication" header for the creation of a DeviceServer and SessionServer.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the Token's last update."
    )


class InvoiceExportPdfContentListing(BaseModel):
    pass


class InvoiceItem(BaseModel):
    billing_date: Optional[str] = Field(
        None, description='The billing date of the item.'
    )
    id: Optional[int] = Field(None, description='The id of the invoice item.')
    quantity: Optional[int] = Field(None, description='The number of items priced.')
    total_vat_exclusive: Optional[Amount] = Field(
        None, description='The item price excluding VAT.'
    )
    total_vat_inclusive: Optional[Amount] = Field(
        None, description='The item price including VAT.'
    )
    type_description: Optional[str] = Field(None, description='The price description.')
    type_description_translated: Optional[str] = Field(
        None, description='The translated price description.'
    )
    unit_vat_exclusive: Optional[Amount] = Field(
        None, description='The unit item price excluding VAT.'
    )
    unit_vat_inclusive: Optional[Amount] = Field(
        None, description='The unit item price including VAT.'
    )
    vat: Optional[int] = Field(None, description='The VAT tax fraction.')


class InvoiceItemGroup(BaseModel):
    instance_description: Optional[str] = Field(
        None, description='The identifier of the invoice item group.'
    )
    item: Optional[List[InvoiceItem]] = Field(
        None, description='The invoice items in the group.'
    )
    product_vat_exclusive: Optional[Amount] = Field(
        None, description='The unit item price excluding VAT.'
    )
    product_vat_inclusive: Optional[Amount] = Field(
        None, description='The unit item price including VAT.'
    )
    type: Optional[str] = Field(None, description='The type of the invoice item group.')
    type_description: Optional[str] = Field(
        None, description='The description of the type of the invoice item group.'
    )
    type_description_translated: Optional[str] = Field(
        None,
        description='The translated description of the type of the invoice item group.',
    )


class Issuer(BaseModel):
    bic: Optional[str] = Field(None, description='The BIC code.')
    name: Optional[str] = Field(None, description='The name of the bank.')


class MasterCardActionReference(BaseModel):
    event_id: Optional[int] = Field(None, description='The id of the event.')


class MasterCardIdentityCheckChallengeRequestUser(BaseModel):
    status: str = Field(
        ...,
        description='The status of the identity check. Can be ACCEPTED_PENDING_RESPONSE or REJECTED_PENDING_RESPONSE.',
    )


class MasterCardIdentityCheckChallengeRequestUserUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class MasterCardPaymentListing(BaseModel):
    pass


class MonetaryAccountBankCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class MonetaryAccountBankUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class MonetaryAccountJointCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class MonetaryAccountJointUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class MonetaryAccountProfileFill(BaseModel):
    balance_preferred: Optional[Amount] = Field(None, description='The goal balance.')
    balance_threshold_low: Optional[Amount] = Field(
        None, description='The low threshold balance.'
    )
    issuer: Optional[Issuer] = Field(
        None,
        description='The bank the fill is supposed to happen from, with BIC and bank name.',
    )
    method_fill: Optional[str] = Field(
        None,
        description='The method used to fill the monetary account. Currently only iDEAL is supported, and it is the default one.',
    )
    status: Optional[str] = Field(None, description='The status of the profile.')


class MonetaryAccountSavingsCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class MonetaryAccountSavingsUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class MonetaryAccountSetting(BaseModel):
    color: Optional[str] = Field(
        None, description='The color chosen for the MonetaryAccount.'
    )
    default_avatar_status: Optional[str] = Field(
        None,
        description='The status of the avatar. Can be either AVATAR_DEFAULT, AVATAR_CUSTOM or AVATAR_UNDETERMINED.',
    )
    icon: Optional[str] = Field(
        None, description='The icon chosen for the MonetaryAccount.'
    )
    restriction_chat: Optional[str] = Field(
        None,
        description='The chat restriction. Possible values are ALLOW_INCOMING or BLOCK_INCOMING',
    )
    sdd_expiration_action: Optional[str] = Field(
        None,
        description='The preference for this monetary account on whether to automatically accept or reject expiring SDDs.',
    )


class NoteAttachmentBankSwitchServiceNetherlandsIncomingPayment(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentDelete(BaseModel):
    pass


class NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentBunqMeFundraiserResult(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentBunqMeFundraiserResultCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentBunqMeFundraiserResultDelete(BaseModel):
    pass


class NoteAttachmentBunqMeFundraiserResultUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentDraftPayment(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentDraftPaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentDraftPaymentDelete(BaseModel):
    pass


class NoteAttachmentDraftPaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentIdealMerchantTransaction(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentIdealMerchantTransactionCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentIdealMerchantTransactionDelete(BaseModel):
    pass


class NoteAttachmentIdealMerchantTransactionUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentMasterCardAction(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentMasterCardActionCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentMasterCardActionDelete(BaseModel):
    pass


class NoteAttachmentMasterCardActionUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentPayment(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentPaymentBatch(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentPaymentBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentPaymentBatchDelete(BaseModel):
    pass


class NoteAttachmentPaymentBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentPaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentPaymentDelete(BaseModel):
    pass


class NoteAttachmentPaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentRequestInquiry(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentRequestInquiryBatch(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentRequestInquiryBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentRequestInquiryBatchDelete(BaseModel):
    pass


class NoteAttachmentRequestInquiryBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentRequestInquiryCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentRequestInquiryDelete(BaseModel):
    pass


class NoteAttachmentRequestInquiryUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentRequestResponse(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentRequestResponseCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentRequestResponseDelete(BaseModel):
    pass


class NoteAttachmentRequestResponseUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentScheduleInstance(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentScheduleInstanceCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentScheduleInstanceDelete(BaseModel):
    pass


class NoteAttachmentScheduleInstanceUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentSchedulePayment(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentSchedulePaymentBatch(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentSchedulePaymentBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentSchedulePaymentBatchDelete(BaseModel):
    pass


class NoteAttachmentSchedulePaymentBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentSchedulePaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentSchedulePaymentDelete(BaseModel):
    pass


class NoteAttachmentSchedulePaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentSofortMerchantTransaction(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentSofortMerchantTransactionCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentSofortMerchantTransactionDelete(BaseModel):
    pass


class NoteAttachmentSofortMerchantTransactionUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentWhitelistResult(BaseModel):
    attachment_id: int = Field(
        ..., description='The reference to the uploaded file to attach to this note.'
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )


class NoteAttachmentWhitelistResultCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteAttachmentWhitelistResultDelete(BaseModel):
    pass


class NoteAttachmentWhitelistResultUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextBankSwitchServiceNetherlandsIncomingPayment(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextBankSwitchServiceNetherlandsIncomingPaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextBankSwitchServiceNetherlandsIncomingPaymentDelete(BaseModel):
    pass


class NoteTextBankSwitchServiceNetherlandsIncomingPaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextBunqMeFundraiserResult(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextBunqMeFundraiserResultCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextBunqMeFundraiserResultDelete(BaseModel):
    pass


class NoteTextBunqMeFundraiserResultUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextDraftPayment(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextDraftPaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextDraftPaymentDelete(BaseModel):
    pass


class NoteTextDraftPaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextIdealMerchantTransaction(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextIdealMerchantTransactionCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextIdealMerchantTransactionDelete(BaseModel):
    pass


class NoteTextIdealMerchantTransactionUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextMasterCardAction(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextMasterCardActionCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextMasterCardActionDelete(BaseModel):
    pass


class NoteTextMasterCardActionUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextPayment(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextPaymentBatch(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextPaymentBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextPaymentBatchDelete(BaseModel):
    pass


class NoteTextPaymentBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextPaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextPaymentDelete(BaseModel):
    pass


class NoteTextPaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextRequestInquiry(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextRequestInquiryBatch(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextRequestInquiryBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextRequestInquiryBatchDelete(BaseModel):
    pass


class NoteTextRequestInquiryBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextRequestInquiryCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextRequestInquiryDelete(BaseModel):
    pass


class NoteTextRequestInquiryUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextRequestResponse(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextRequestResponseCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextRequestResponseDelete(BaseModel):
    pass


class NoteTextRequestResponseUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextScheduleInstance(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextScheduleInstanceCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextScheduleInstanceDelete(BaseModel):
    pass


class NoteTextScheduleInstanceUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextSchedulePayment(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextSchedulePaymentBatch(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextSchedulePaymentBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextSchedulePaymentBatchDelete(BaseModel):
    pass


class NoteTextSchedulePaymentBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextSchedulePaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextSchedulePaymentDelete(BaseModel):
    pass


class NoteTextSchedulePaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextSofortMerchantTransaction(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextSofortMerchantTransactionCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextSofortMerchantTransactionDelete(BaseModel):
    pass


class NoteTextSofortMerchantTransactionUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextWhitelistResult(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')


class NoteTextWhitelistResultCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NoteTextWhitelistResultDelete(BaseModel):
    pass


class NoteTextWhitelistResultUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NotificationFilter(BaseModel):
    category: Optional[str] = Field(
        None,
        description='The notification category that will match this notification filter. Possible choices are BILLING, CARD_TRANSACTION_FAILED, CARD_TRANSACTION_SUCCESSFUL, CHAT, DRAFT_PAYMENT, IDEAL, SOFORT, MONETARY_ACCOUNT_PROFILE, MUTATION, PAYMENT, PROMOTION, REQUEST, SCHEDULE_RESULT, SCHEDULE_STATUS, SHARE, SUPPORT, TAB_RESULT, USER_APPROVAL.',
    )
    notification_delivery_method: Optional[str] = Field(
        None,
        description='The delivery method via which notifications that match this notification filter will be delivered. Possible choices are PUSH for delivery via push notification and URL for delivery via URL callback.',
    )
    notification_target: Optional[str] = Field(
        None,
        description='The target of notifications that match this notification filter. For URL notification filters this is the URL to which the callback will be made. For PUSH notifications filters this should always be null.',
    )


class NotificationFilterEmail(BaseModel):
    notification_filters: Optional[List[NotificationFilterEmail]] = Field(
        None,
        description='The types of notifications that will result in a email notification for this user.',
    )


class NotificationFilterEmailCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NotificationFilterEmailListing(BaseModel):
    notification_filters: Optional[List[NotificationFilterEmail]] = Field(
        None,
        description='The types of notifications that will result in a email notification for this user.',
    )


class NotificationFilterPush(BaseModel):
    notification_filters: Optional[List[NotificationFilterPush]] = Field(
        None,
        description='The types of notifications that will result in a push notification for this user.',
    )


class NotificationFilterPushCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NotificationFilterPushListing(BaseModel):
    notification_filters: Optional[List[NotificationFilterPush]] = Field(
        None,
        description='The types of notifications that will result in a push notification for this user.',
    )


class NotificationFilterUrl(BaseModel):
    notification_filters: Optional[List[NotificationFilterUrl]] = Field(
        None,
        description='The types of notifications that will result in a url notification for this user.',
    )


class NotificationFilterUrlCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NotificationFilterUrlListing(BaseModel):
    notification_filters: Optional[List[NotificationFilterUrl]] = Field(
        None,
        description='The types of notifications that will result in a url notification for this user.',
    )


class NotificationFilterUrlMonetaryAccount(BaseModel):
    notification_filters: Optional[List[NotificationFilterUrl]] = Field(
        None,
        description='The types of notifications that will result in a url notification for this monetary account.',
    )


class NotificationFilterUrlMonetaryAccountCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class NotificationFilterUrlMonetaryAccountListing(BaseModel):
    notification_filters: Optional[List[NotificationFilterUrl]] = Field(
        None,
        description='The types of notifications that will result in a url notification for this monetary account.',
    )


class OauthCallbackUrl(BaseModel):
    url: str = Field(..., description='The URL for this callback.')


class OauthCallbackUrlCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class OauthCallbackUrlDelete(BaseModel):
    pass


class OauthCallbackUrlListing(BaseModel):
    url: Optional[str] = Field(None, description='The URL for this callback.')


class OauthCallbackUrlRead(BaseModel):
    url: Optional[str] = Field(None, description='The URL for this callback.')


class OauthCallbackUrlUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class OauthClient(BaseModel):
    status: Optional[str] = Field(
        None, description='The status of the Oauth Client, can be ACTIVE or CANCELLED.'
    )


class OauthClientCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class OauthClientListing(BaseModel):
    callback_url: Optional[List[OauthCallbackUrl]] = Field(
        None, description='The callback URLs which are bound to this Oauth Client'
    )
    client_id: Optional[str] = Field(
        None, description='The Client ID associated with this Oauth Client'
    )
    display_name: Optional[str] = Field(
        None, description='The display name of this Oauth Client'
    )
    id: Optional[int] = Field(None, description='Id of the client.')
    secret: Optional[str] = Field(
        None, description='Secret associated with this Oauth Client'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the pack group, can be ACTIVE, CANCELLED or CANCELLED_PENDING.',
    )


class OauthClientRead(BaseModel):
    callback_url: Optional[List[OauthCallbackUrl]] = Field(
        None, description='The callback URLs which are bound to this Oauth Client'
    )
    client_id: Optional[str] = Field(
        None, description='The Client ID associated with this Oauth Client'
    )
    display_name: Optional[str] = Field(
        None, description='The display name of this Oauth Client'
    )
    id: Optional[int] = Field(None, description='Id of the client.')
    secret: Optional[str] = Field(
        None, description='Secret associated with this Oauth Client'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the pack group, can be ACTIVE, CANCELLED or CANCELLED_PENDING.',
    )


class OauthClientUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PaymentAutoAllocateCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PaymentAutoAllocateDelete(BaseModel):
    pass


class PaymentAutoAllocateUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PaymentBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PaymentBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PaymentCreate(BaseModel):
    id: Optional[int] = Field(None, description='The id of the created Payment.')


class PaymentServiceProviderCredential(BaseModel):
    client_payment_service_provider_certificate: str = Field(
        ..., description='Payment Services Directive 2 compatible QSEAL certificate'
    )
    client_payment_service_provider_certificate_chain: str = Field(
        ...,
        description='Intermediate and root certificate belonging to the provided certificate.',
    )
    client_public_key_signature: str = Field(
        ...,
        description='The Base64 encoded signature of the public key provided during installation and with the installation token appended as a nonce. Signed with the private key belonging to the QSEAL certificate.',
    )


class PaymentServiceProviderCredentialCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PaymentServiceProviderDraftPayment(BaseModel):
    amount: Amount = Field(
        ...,
        description='The Amount to transfer with the Payment. Must be bigger than 0.',
    )
    counterparty_iban: str = Field(..., description='The IBAN of the counterparty.')
    counterparty_name: str = Field(..., description='The name of the counterparty.')
    description: str = Field(..., description='Description of the payment.')
    sender_iban: str = Field(..., description='The IBAN of the sender.')
    sender_name: Optional[str] = Field(None, description='The name of the sender.')
    status: Optional[str] = Field(
        None,
        description='The new status of the Draft Payment. Can only be set to REJECTED or CANCELLED by update.',
    )


class PaymentServiceProviderDraftPaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PaymentServiceProviderDraftPaymentListing(BaseModel):
    amount: Optional[Amount] = Field(
        None, description='The amount of the draft payment'
    )
    receiver_iban: Optional[str] = Field(None, description='The sender IBAN.')
    sender_iban: Optional[str] = Field(None, description='The sender IBAN.')
    status: Optional[str] = Field(None, description='The status of the draft payment')


class PaymentServiceProviderDraftPaymentRead(BaseModel):
    amount: Optional[Amount] = Field(
        None, description='The amount of the draft payment'
    )
    receiver_iban: Optional[str] = Field(None, description='The sender IBAN.')
    sender_iban: Optional[str] = Field(None, description='The sender IBAN.')
    status: Optional[str] = Field(None, description='The status of the draft payment')


class PaymentServiceProviderDraftPaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PermittedDevice(BaseModel):
    description: Optional[str] = Field(
        None, description='The description of the device that may use the credential.'
    )
    ip: Optional[str] = Field(
        None, description='The IP address of the device that may use the credential.'
    )


class PermittedIp(BaseModel):
    ip: str = Field(..., description='The IP address.')
    status: Optional[str] = Field(
        None,
        description='The status of the IP. May be "ACTIVE" or "INACTIVE". It is only possible to make requests from "ACTIVE" IP addresses. Only "ACTIVE" IPs will be billed.',
    )


class PermittedIpCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PermittedIpListing(BaseModel):
    ip: Optional[str] = Field(None, description='The IP address.')
    status: Optional[str] = Field(
        None,
        description='The status of the IP. May be "ACTIVE" or "INACTIVE". It is only possible to make requests from "ACTIVE" IP addresses. Only "ACTIVE" IPs will be billed.',
    )


class PermittedIpRead(BaseModel):
    ip: Optional[str] = Field(None, description='The IP address.')
    status: Optional[str] = Field(
        None,
        description='The status of the IP. May be "ACTIVE" or "INACTIVE". It is only possible to make requests from "ACTIVE" IP addresses. Only "ACTIVE" IPs will be billed.',
    )


class PermittedIpUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class PlacePhotoLookupContentListing(BaseModel):
    pass


class Pointer(BaseModel):
    name: Optional[str] = Field(None, description='The alias name.')
    service: Optional[str] = Field(
        None,
        description='The pointer service. Only required for external counterparties.',
    )
    type: Optional[str] = Field(
        None, description='The alias type, can be: EMAIL|PHONE_NUMBER|IBAN.'
    )
    value: Optional[str] = Field(None, description='The alias value.')


class RegistrySettlement(BaseModel):
    pass


class RegistrySettlementCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class RequestInquiryBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class RequestInquiryBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class RequestInquiryCreate(BaseModel):
    id: Optional[int] = Field(None, description='The id of the created RequestInquiry.')


class RequestInquiryReference(BaseModel):
    id: Optional[int] = Field(
        None, description='The id of the request inquiry (batch).'
    )
    type: Optional[str] = Field(
        None,
        description='The type of request inquiry. Can be RequestInquiry or RequestInquiryBatch.',
    )


class RequestResponseUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class SandboxUserCompany(BaseModel):
    pass


class SandboxUserCompanyCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class SandboxUserPerson(BaseModel):
    pass


class SandboxUserPersonCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class ScheduleInstanceUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class SchedulePaymentBatchCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class SchedulePaymentBatchDelete(BaseModel):
    pass


class SchedulePaymentBatchUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class SchedulePaymentCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class SchedulePaymentDelete(BaseModel):
    pass


class SchedulePaymentUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class ScheduleUserListing(BaseModel):
    pass


class ServerError(BaseModel):
    pass


class ServerErrorCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class SessionDelete(BaseModel):
    pass


class SessionServer(BaseModel):
    secret: str = Field(
        ...,
        description='The API key of the user you want to login. If your API key has not been used before, it will be bound to the ip address of this DeviceServer.',
    )


class SessionServerToken(BaseModel):
    id: Optional[int] = Field(None, description='The id of the Token.')
    token: Optional[str] = Field(
        None,
        description='The Session token is the token the client has to provide in the "X-Bunq-Client-Authentication" header for each API call that requires a Session (only the creation of a Installation and DeviceServer don\'t require a Session).',
    )


class ShareDetailDraftPayment(BaseModel):
    make_draft_payments: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to make draft payments from the shared account.',
    )
    view_balance: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view the account balance.',
    )
    view_new_events: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view events starting from the time the share became active.',
    )
    view_old_events: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view events from before the share was active.',
    )


class ShareDetailPayment(BaseModel):
    make_draft_payments: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to make draft payments from the shared account.',
    )
    make_payments: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to make payments from the shared account.',
    )
    view_balance: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view the account balance.',
    )
    view_new_events: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view events starting from the time the share became active.',
    )
    view_old_events: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view events from before the share was active.',
    )


class ShareDetailReadOnly(BaseModel):
    view_balance: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view the account balance.',
    )
    view_new_events: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view events starting from the time the share became active.',
    )
    view_old_events: Optional[bool] = Field(
        None,
        description='If set to true, the invited user will be able to view events from before the share was active.',
    )


class ShareInviteMonetaryAccountInquiryCreate(BaseModel):
    id: Optional[int] = Field(
        None, description='The id of the newly created share invite.'
    )


class ShareInviteMonetaryAccountInquiryUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class ShareInviteMonetaryAccountResponseUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TaxResident(BaseModel):
    country: Optional[str] = Field(None, description='The country of the tax number.')
    status: Optional[str] = Field(
        None,
        description='The status of the tax number. Either CONFIRMED or UNCONFIRMED.',
    )
    tax_number: Optional[str] = Field(None, description='The tax number.')


class TokenQrRequestIdeal(BaseModel):
    token: str = Field(
        ..., description='The token passed from a site or read from a QR code.'
    )


class TokenQrRequestSofort(BaseModel):
    token: str = Field(
        ..., description='The token passed from a site or read from a QR code.'
    )


class TokenQrRequestSofortCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TransferwiseAccountQuoteCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TransferwiseAccountQuoteDelete(BaseModel):
    pass


class TransferwiseAccountQuoteListing(BaseModel):
    account_id: Optional[str] = Field(
        None, description="Transferwise's id of the account."
    )
    account_number: Optional[str] = Field(None, description='The account number.')
    bank_code: Optional[str] = Field(None, description='The bank code.')
    country: Optional[str] = Field(None, description='The country of the account.')
    currency: Optional[str] = Field(None, description='The currency the account.')
    name_account_holder: Optional[str] = Field(
        None, description='The name of the account holder.'
    )


class TransferwiseAccountQuoteRead(BaseModel):
    account_id: Optional[str] = Field(
        None, description="Transferwise's id of the account."
    )
    account_number: Optional[str] = Field(None, description='The account number.')
    bank_code: Optional[str] = Field(None, description='The bank code.')
    country: Optional[str] = Field(None, description='The country of the account.')
    currency: Optional[str] = Field(None, description='The currency the account.')
    name_account_holder: Optional[str] = Field(
        None, description='The name of the account holder.'
    )


class TransferwiseAccountRequirementCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TransferwiseCurrencyListing(BaseModel):
    country: Optional[str] = Field(
        None, description='The country code associated with the currency.'
    )
    currency: Optional[str] = Field(None, description='The currency code.')
    name: Optional[str] = Field(None, description='The currency name.')


class TransferwiseQuote(BaseModel):
    amount_fee: Optional[Amount] = Field(None, description='The fee amount.')
    amount_source: Optional[Amount] = Field(None, description='The source amount.')
    amount_target: Optional[Amount] = Field(None, description='The target amount.')
    created: Optional[str] = Field(
        None, description="The timestamp of the quote's creation."
    )
    currency_source: str = Field(..., description='The source currency.')
    currency_target: str = Field(..., description='The target currency.')
    id: Optional[int] = Field(None, description='The id of the quote.')
    quote_id: Optional[str] = Field(
        None, description='The quote id Transferwise needs.'
    )
    rate: Optional[str] = Field(None, description='The rate.')
    time_delivery_estimate: Optional[str] = Field(
        None, description='The estimated delivery time.'
    )
    time_expiry: Optional[str] = Field(
        None, description='The expiration timestamp of the quote.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the quote's last update."
    )


class TransferwiseQuoteCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TransferwiseQuoteRead(BaseModel):
    amount_fee: Optional[Amount] = Field(None, description='The fee amount.')
    amount_source: Optional[Amount] = Field(None, description='The source amount.')
    amount_target: Optional[Amount] = Field(None, description='The target amount.')
    created: Optional[str] = Field(
        None, description="The timestamp of the quote's creation."
    )
    id: Optional[int] = Field(None, description='The id of the quote.')
    quote_id: Optional[str] = Field(
        None, description='The quote id Transferwise needs.'
    )
    rate: Optional[str] = Field(None, description='The rate.')
    time_delivery_estimate: Optional[str] = Field(
        None, description='The estimated delivery time.'
    )
    time_expiry: Optional[str] = Field(
        None, description='The expiration timestamp of the quote.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the quote's last update."
    )


class TransferwiseQuoteTemporary(BaseModel):
    amount_source: Optional[Amount] = Field(
        None, description='The source amount. Required if target amount is left empty.'
    )
    amount_target: Optional[Amount] = Field(
        None, description='The target amount. Required if source amount is left empty.'
    )
    currency_source: str = Field(..., description='The source currency.')
    currency_target: str = Field(..., description='The target currency.')


class TransferwiseQuoteTemporaryCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TransferwiseQuoteTemporaryRead(BaseModel):
    amount_source: Optional[Amount] = Field(None, description='The source amount.')
    amount_target: Optional[Amount] = Field(None, description='The target amount.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the quote.')
    quote_id: Optional[str] = Field(
        None,
        description='The quote id Transferwise needs. Will always be null for temporary quotes.',
    )
    rate: Optional[str] = Field(None, description='The rate.')
    time_expiry: Optional[str] = Field(
        None,
        description='The expiration timestamp of the quote. Will always be null for temporary quotes.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class TransferwiseRequirementFieldGroupValidationAsyncParams(BaseModel):
    key: Optional[str] = Field(None, description='The parameter key.')
    parameter_name: Optional[str] = Field(None, description='The parameter label.')
    required: Optional[bool] = Field(
        None, description='Shows whether the parameter is required or not.'
    )


class TransferwiseRequirementFieldGroupValuesAllowed(BaseModel):
    key: Optional[str] = Field(None, description='The key.')
    name: Optional[str] = Field(None, description='The label.')


class TransferwiseTransferCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TransferwiseTransferRequirementCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TransferwiseUser(BaseModel):
    oauth_code: Optional[str] = Field(
        None,
        description="The OAuth code returned by Transferwise we should be using to gain access to the user's Transferwise account.",
    )


class TransferwiseUserCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class TransferwiseUserListing(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the TransferwiseUser's creation."
    )
    email: Optional[str] = Field(
        None, description='The email the user is registered with at TransferWise.'
    )
    id: Optional[int] = Field(None, description='The id of the TransferwiseUser.')
    name: Optional[str] = Field(
        None, description='The name the user is registered with at TransferWise.'
    )
    source: Optional[str] = Field(
        None, description='The source of the user at TransferWise.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the TransferwiseUser's last update."
    )


class TranslinkTransactionCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class Ubo(BaseModel):
    date_of_birth: Optional[str] = Field(
        None, description='The date of birth of the ultimate beneficiary owner.'
    )
    name: Optional[str] = Field(
        None, description='The name of the ultimate beneficiary owner.'
    )
    nationality: Optional[str] = Field(
        None, description='The nationality of the ultimate beneficiary owner.'
    )


class UserCompanyNameListing(BaseModel):
    name_array: Optional[List[str]] = Field(
        None, description='All known (trade) names for a user company.'
    )


class UserCompanyUpdate(BaseModel):
    id: Optional[int] = Field(None, description='The id of the modified company.')


class UserCredentialPasswordIpListing(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the credential object's creation."
    )
    expiry_time: Optional[str] = Field(
        None,
        description='When the status is PENDING_FIRST_USE: when the credential expires.',
    )
    id: Optional[int] = Field(None, description='The id of the credential.')
    permitted_device: Optional[PermittedDevice] = Field(
        None,
        description='When the status is ACTIVE: the details of the device that may use the credential.',
    )
    status: Optional[str] = Field(None, description='The status of the credential.')
    token_value: Optional[str] = Field(
        None,
        description='When the status is PENDING_FIRST_USE: the value of the token.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the credential object's last update."
    )


class UserCredentialPasswordIpRead(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the credential object's creation."
    )
    expiry_time: Optional[str] = Field(
        None,
        description='When the status is PENDING_FIRST_USE: when the credential expires.',
    )
    id: Optional[int] = Field(None, description='The id of the credential.')
    permitted_device: Optional[PermittedDevice] = Field(
        None,
        description='When the status is ACTIVE: the details of the device that may use the credential.',
    )
    status: Optional[str] = Field(None, description='The status of the credential.')
    token_value: Optional[str] = Field(
        None,
        description='When the status is PENDING_FIRST_USE: the value of the token.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the credential object's last update."
    )


class UserLegalNameListing(BaseModel):
    legal_names: Optional[List[str]] = Field(
        None, description='All legal names that can be used by the user'
    )


class UserPersonUpdate(BaseModel):
    id: Optional[int] = Field(None, description='The id of the modified person object.')


class Whitelist(BaseModel):
    pass


class WhitelistSddOneOff(BaseModel):
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The maximum amount of money that is allowed to be deducted based on the whitelist.',
    )
    monetary_account_paying_id: int = Field(
        ..., description='ID of the monetary account of which you want to pay from.'
    )
    request_id: int = Field(
        ...,
        description='ID of the request for which you want to whitelist the originating SDD.',
    )


class WhitelistSddOneOffCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class WhitelistSddOneOffDelete(BaseModel):
    pass


class WhitelistSddOneOffUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class WhitelistSddRecurring(BaseModel):
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The maximum amount of money that is allowed to be deducted based on the whitelist.',
    )
    monetary_account_paying_id: int = Field(
        ..., description='ID of the monetary account of which you want to pay from.'
    )
    request_id: int = Field(
        ...,
        description='ID of the request for which you want to whitelist the originating SDD.',
    )


class WhitelistSddRecurringCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class WhitelistSddRecurringDelete(BaseModel):
    pass


class WhitelistSddRecurringUpdate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class AttachmentPublicPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class AttachmentPublicAttachmentPublicUUIDContentGetResponse(
    RootModel[List[AttachmentPublicContentListing]]
):
    root: List[AttachmentPublicContentListing]


class AttachmentPublicAttachmentPublicUUIDContentGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class AttachmentPublicItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class AvatarPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class AvatarItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class DeviceGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class DeviceServerGetResponse(RootModel[List[DeviceServerListing]]):
    root: List[DeviceServerListing]


class DeviceServerGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class DeviceServerPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class DeviceServerItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class DeviceItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class InstallationGetResponse(RootModel[List[InstallationListing]]):
    root: List[InstallationListing]


class InstallationGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class InstallationPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class InstallationInstallationIDServerPublicKeyGetResponse(
    RootModel[List[InstallationServerPublicKeyListing]]
):
    root: List[InstallationServerPublicKeyListing]


class InstallationInstallationIDServerPublicKeyGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class InstallationItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class PaymentServiceProviderCredentialPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class PaymentServiceProviderCredentialItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class PlaceLookupPlaceLookupIDPhotoPhotoIDContentGetResponse(
    RootModel[List[PlacePhotoLookupContentListing]]
):
    root: List[PlacePhotoLookupContentListing]


class PlaceLookupPlaceLookupIDPhotoPhotoIDContentGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class SandboxUserCompanyPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class SandboxUserPersonPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class ServerErrorPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class SessionServerPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class SessionItemIdDeleteResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserCompanyItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserCompanyItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserCompanyUserCompanyIDNameGetResponse(RootModel[List[UserCompanyNameListing]]):
    root: List[UserCompanyNameListing]


class UserCompanyUserCompanyIDNameGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserPaymentServiceProviderItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserPersonItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserPersonItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDAttachmentAttachmentIDContentGetResponse(
    RootModel[List[AttachmentUserContentListing]]
):
    root: List[AttachmentUserContentListing]


class UserUserIDAttachmentAttachmentIDContentGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDAttachmentItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDBillingContractSubscriptionGetResponse(
    RootModel[List[BillingContractSubscriptionListing]]
):
    root: List[BillingContractSubscriptionListing]


class UserUserIDBillingContractSubscriptionGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDBunqmeFundraiserProfileGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDBunqmeFundraiserProfileItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardBatchPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardBatchReplacePostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCreditPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardDebitPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardNameGetResponse(RootModel[List[CardNameListing]]):
    root: List[CardNameListing]


class UserUserIDCardNameGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardGetResponse(
    RootModel[List[ExportStatementCardListing]]
):
    root: List[ExportStatementCardListing]


class UserUserIDCardCardIDExportStatementCardGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardCsvGetResponse(
    RootModel[List[ExportStatementCardCsvListing]]
):
    root: List[ExportStatementCardCsvListing]


class UserUserIDCardCardIDExportStatementCardCsvGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardCsvPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardCsvItemIdDeleteResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardCsvItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardPdfGetResponse(
    RootModel[List[ExportStatementCardPdfListing]]
):
    root: List[ExportStatementCardPdfListing]


class UserUserIDCardCardIDExportStatementCardPdfGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardPdfPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardPdfItemIdDeleteResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardPdfItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardExportStatementCardIDContentGetResponse(
    RootModel[List[ExportStatementCardContentListing]]
):
    root: List[ExportStatementCardContentListing]


class UserUserIDCardCardIDExportStatementCardExportStatementCardIDContentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDExportStatementCardItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDGeneratedCvc2GetResponse(
    RootModel[List[CardGeneratedCvc2Listing]]
):
    root: List[CardGeneratedCvc2Listing]


class UserUserIDCardCardIDGeneratedCvc2GetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDGeneratedCvc2PostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDGeneratedCvc2ItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDGeneratedCvc2ItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardCardIDReplacePostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCardItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCertificatePinnedGetResponse(RootModel[List[CertificatePinnedListing]]):
    root: List[CertificatePinnedListing]


class UserUserIDCertificatePinnedGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCertificatePinnedPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCertificatePinnedItemIdDeleteResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCertificatePinnedItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDChallengeRequestItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDChallengeRequestItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDChatConversationChatConversationIDAttachmentAttachmentIDContentGetResponse(
    RootModel[List[AttachmentConversationContentListing]]
):
    root: List[AttachmentConversationContentListing]


class UserUserIDChatConversationChatConversationIDAttachmentAttachmentIDContentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCompanyGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCompanyPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCompanyItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCompanyItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDConfirmationOfFundsPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCredentialPasswordIpGetResponse(
    RootModel[List[UserCredentialPasswordIpListing]]
):
    root: List[UserCredentialPasswordIpListing]


class UserUserIDCredentialPasswordIpGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCredentialPasswordIpCredentialPasswordIpIDIpGetResponse(
    RootModel[List[PermittedIpListing]]
):
    root: List[PermittedIpListing]


class UserUserIDCredentialPasswordIpCredentialPasswordIpIDIpGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCredentialPasswordIpCredentialPasswordIpIDIpPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCredentialPasswordIpCredentialPasswordIpIDIpItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCredentialPasswordIpCredentialPasswordIpIDIpItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCredentialPasswordIpItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCurrencyCloudBeneficiaryGetResponse(
    RootModel[List[CurrencyCloudBeneficiaryListing]]
):
    root: List[CurrencyCloudBeneficiaryListing]


class UserUserIDCurrencyCloudBeneficiaryGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCurrencyCloudBeneficiaryPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCurrencyCloudBeneficiaryRequirementGetResponse(
    RootModel[List[CurrencyCloudBeneficiaryRequirementListing]]
):
    root: List[CurrencyCloudBeneficiaryRequirementListing]


class UserUserIDCurrencyCloudBeneficiaryRequirementGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDCurrencyCloudBeneficiaryItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDEventGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDEventItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDExportAnnualOverviewGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDExportAnnualOverviewPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDExportAnnualOverviewExportAnnualOverviewIDContentGetResponse(
    RootModel[List[ExportAnnualOverviewContentListing]]
):
    root: List[ExportAnnualOverviewContentListing]


class UserUserIDExportAnnualOverviewExportAnnualOverviewIDContentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDExportAnnualOverviewItemIdDeleteResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDExportAnnualOverviewItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDFeatureAnnouncementItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDInsightPreferenceDateGetResponse(
    RootModel[List[InsightPreferenceDateListing]]
):
    root: List[InsightPreferenceDateListing]


class UserUserIDInsightPreferenceDateGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDInsightsGetResponse(RootModel[List[InsightListing]]):
    root: List[InsightListing]


class UserUserIDInsightsGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDInsightsSearchGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDInvoiceGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDInvoiceInvoiceIDPdfContentGetResponse(
    RootModel[List[InvoiceExportPdfContentListing]]
):
    root: List[InvoiceExportPdfContentListing]


class UserUserIDInvoiceInvoiceIDPdfContentGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDInvoiceItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDLegalNameGetResponse(RootModel[List[UserLegalNameListing]]):
    root: List[UserLegalNameListing]


class UserUserIDLegalNameGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDLimitGetResponse(RootModel[List[CustomerLimitListing]]):
    root: List[CustomerLimitListing]


class UserUserIDLimitGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountBankGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountBankPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountBankItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountBankItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountExternalGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountExternalItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountJointGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountJointPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountJointItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountJointItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountSavingsGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountSavingsPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountSavingsItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountSavingsItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDAttachmentPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDAttachmentAttachmentIDContentGetResponse(
    RootModel[List[AttachmentMonetaryAccountContentListing]]
):
    root: List[AttachmentMonetaryAccountContentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDAttachmentAttachmentIDContentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeTabGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeTabPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeTabResultResponseItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeTabItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeTabItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCurrencyCloudPaymentQuotePostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCurrencyConversionGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCurrencyConversionQuotePostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCurrencyConversionQuoteItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCurrencyConversionQuoteItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCurrencyConversionItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCustomerStatementGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCustomerStatementPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCustomerStatementCustomerStatementIDContentGetResponse(
    RootModel[List[ExportStatementContentListing]]
):
    root: List[ExportStatementContentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDCustomerStatementCustomerStatementIDContentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCustomerStatementItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDCustomerStatementItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDEventEventIDStatementPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDEventEventIDStatementItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDEventEventIDStatementStatementIDContentGetResponse(
    RootModel[List[ExportStatementPaymentContentListing]]
):
    root: List[ExportStatementPaymentContentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDEventEventIDStatementStatementIDContentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDExportRibGetResponse(
    RootModel[List[ExportRibListing]]
):
    root: List[ExportRibListing]


class UserUserIDMonetaryAccountMonetaryAccountIDExportRibGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDExportRibPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDExportRibExportRibIDContentGetResponse(
    RootModel[List[ExportRibContentListing]]
):
    root: List[ExportRibContentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDExportRibExportRibIDContentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDExportRibItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDExportRibItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDInvoiceGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDInvoiceItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDPaymentGetResponse(
    RootModel[List[MasterCardPaymentListing]]
):
    root: List[MasterCardPaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDPaymentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDNotificationFilterUrlGetResponse(
    RootModel[List[NotificationFilterUrlMonetaryAccountListing]]
):
    root: List[NotificationFilterUrlMonetaryAccountListing]


class UserUserIDMonetaryAccountMonetaryAccountIDNotificationFilterUrlGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDNotificationFilterUrlPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocateGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocatePostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocateItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocateItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocateItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocatePaymentAutoAllocateIDDefinitionGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocatePaymentAutoAllocateIDInstanceGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocatePaymentAutoAllocateIDInstanceItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDShareInviteMonetaryAccountInquiryGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDShareInviteMonetaryAccountInquiryPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDShareInviteMonetaryAccountInquiryItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDShareInviteMonetaryAccountInquiryItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDTranslinkTransactionGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDTranslinkTransactionPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDTranslinkTransactionItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistSddGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistSddItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteAttachmentGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteAttachmentPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteAttachmentItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteAttachmentItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteAttachmentItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteTextGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteTextPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteTextItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteTextItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteTextItemIdPutResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDNotificationFilterEmailGetResponse(
    RootModel[List[NotificationFilterEmailListing]]
):
    root: List[NotificationFilterEmailListing]


class UserUserIDNotificationFilterEmailGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDNotificationFilterEmailPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDNotificationFilterPushGetResponse(
    RootModel[List[NotificationFilterPushListing]]
):
    root: List[NotificationFilterPushListing]


class UserUserIDNotificationFilterPushGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDNotificationFilterPushPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDNotificationFilterUrlGetResponse(
    RootModel[List[NotificationFilterUrlListing]]
):
    root: List[NotificationFilterUrlListing]


class UserUserIDNotificationFilterUrlGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDNotificationFilterUrlPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientGetResponse(RootModel[List[OauthClientListing]]):
    root: List[OauthClientListing]


class UserUserIDOauthClientGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientOauthClientIDCallbackUrlGetResponse(
    RootModel[List[OauthCallbackUrlListing]]
):
    root: List[OauthCallbackUrlListing]


class UserUserIDOauthClientOauthClientIDCallbackUrlGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientOauthClientIDCallbackUrlPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientOauthClientIDCallbackUrlItemIdDeleteResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientOauthClientIDCallbackUrlItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDOauthClientOauthClientIDCallbackUrlItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDPaymentAutoAllocateGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDPaymentServiceProviderDraftPaymentGetResponse(
    RootModel[List[PaymentServiceProviderDraftPaymentListing]]
):
    root: List[PaymentServiceProviderDraftPaymentListing]


class UserUserIDPaymentServiceProviderDraftPaymentGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDPaymentServiceProviderDraftPaymentPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDPaymentServiceProviderDraftPaymentItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDPaymentServiceProviderDraftPaymentItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRegistryRegistryIDRegistrySettlementGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRegistryRegistryIDRegistrySettlementPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRegistryRegistryIDRegistrySettlementItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRewardGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRewardRecipientGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRewardRecipientItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRewardSenderGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRewardSenderItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDRewardItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDScheduleGetResponse(RootModel[List[ScheduleUserListing]]):
    root: List[ScheduleUserListing]


class UserUserIDScheduleGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDShareInviteMonetaryAccountResponseGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDShareInviteMonetaryAccountResponseItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDShareInviteMonetaryAccountResponseItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTokenQrRequestIdealPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTokenQrRequestSofortPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseCurrencyGetResponse(
    RootModel[List[TransferwiseCurrencyListing]]
):
    root: List[TransferwiseCurrencyListing]


class UserUserIDTransferwiseCurrencyGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuotePostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTemporaryPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTemporaryItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseRecipientGetResponse(
    RootModel[List[TransferwiseAccountQuoteListing]]
):
    root: List[TransferwiseAccountQuoteListing]


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseRecipientGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseRecipientPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseRecipientRequirementGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseRecipientRequirementPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseRecipientItemIdDeleteResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseRecipientItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseTransferGetResponse1(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseTransferPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseTransferRequirementPostResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseTransferItemIdGetResponse(
    BaseModel
):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseUserGetResponse(RootModel[List[TransferwiseUserListing]]):
    root: List[TransferwiseUserListing]


class UserUserIDTransferwiseUserGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTransferwiseUserPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDTreeProgressGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddOneOffGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddOneOffPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddOneOffItemIdDeleteResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddOneOffItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddOneOffItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddRecurringGetResponse1(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddRecurringPostResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddRecurringItemIdDeleteResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddRecurringItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddRecurringItemIdPutResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class UserUserIDWhitelistSddItemIdGetResponse(BaseModel):
    Error_1: Optional[Error] = Field(None, alias='Error')


class AdditionalInformation(BaseModel):
    attachment: Optional[List[AttachmentMasterCardActionRefund]] = Field(
        None, description='The Attachments to attach to the refund request.'
    )
    category: Optional[str] = Field(
        None, description='The category of the refund, required for chargeback.'
    )
    comment: Optional[str] = Field(None, description='Comment about the refund.')
    reason: Optional[str] = Field(
        None, description='The reason to refund, required for chargeback.'
    )
    terms_and_conditions: Optional[str] = Field(
        None,
        description='Proof that the user acknowledged the terms and conditions for chargebacks.',
    )


class Attachment(BaseModel):
    content_type: Optional[str] = Field(
        None, description="The content type of the attachment's file."
    )
    description: Optional[str] = Field(
        None, description='The description of the attachment.'
    )
    urls: Optional[List[AttachmentUrl]] = Field(
        None, description='The URLs where the file can be downloaded.'
    )


class AttachmentPublicCreate(BaseModel):
    Id: Optional[BunqId] = Field(None, description='The id of the created item')


class AttachmentPublicRead(BaseModel):
    attachment: Optional[Attachment] = Field(None, description='The attachment.')
    created: Optional[str] = Field(
        None, description="The timestamp of the attachment's creation."
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the attachment's last update."
    )
    uuid: Optional[str] = Field(None, description='The UUID of the attachment.')


class AttachmentUserRead(BaseModel):
    attachment: Optional[Attachment] = Field(None, description='The attachment.')
    created: Optional[str] = Field(
        None, description="The timestamp of the attachment's creation."
    )
    id: Optional[int] = Field(None, description='The id of the attachment.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the attachment's last update."
    )


class Avatar(BaseModel):
    anchor_uuid: Optional[str] = Field(
        None, description='The public UUID of object this avatar is anchored to.'
    )
    image: Optional[List[Image]] = Field(
        None, description='The actual image information of this avatar.'
    )
    style: Optional[str] = Field(
        None, description='The style (if applicable) for this Avatar.'
    )
    uuid: Optional[str] = Field(None, description='The public UUID of the avatar.')


class AvatarRead(BaseModel):
    image: Optional[List[Image]] = Field(
        None, description='The content type of the image.'
    )
    uuid: Optional[str] = Field(None, description='The UUID of the created avatar.')


class BirdeeInvestmentPortfolio(BaseModel):
    allocations: Optional[List[BirdeePortfolioAllocation]] = Field(
        None, description='The allocations of the investment portfolio.'
    )
    balance: Optional[BirdeeInvestmentPortfolioBalance] = Field(
        None, description='The investment portfolio balance.'
    )
    goal: Optional[BirdeeInvestmentPortfolioGoal] = Field(
        None, description='The investment goal.'
    )
    investment_theme: Optional[str] = Field(None, description='The investment theme.')
    name: Optional[str] = Field(
        None, description='The name associated with the investment portfolio.'
    )
    number_of_strategy_change_annual_maximum: Optional[int] = Field(
        None, description='Maximum number of strategy changes in a year.'
    )
    number_of_strategy_change_annual_used: Optional[int] = Field(
        None, description='Maximum number of strategy changes used.'
    )
    risk_profile_type: Optional[str] = Field(
        None, description='The type of risk profile associated with the portfolio.'
    )
    status: Optional[str] = Field(None, description='Status of the portfolio.')


class Card(BaseModel):
    activation_code: Optional[str] = Field(
        None,
        description='DEPRECATED: Activate a card by setting status to ACTIVE when the order_status is ACCEPTED_FOR_PRODUCTION.',
    )
    card_limit: Optional[Amount] = Field(
        None, description='The spending limit for the card.'
    )
    card_limit_atm: Optional[Amount] = Field(
        None, description='The ATM spending limit for the card.'
    )
    country_permission: Optional[List[CardCountryPermission]] = Field(
        None,
        description='The countries for which to grant (temporary) permissions to use the card.',
    )
    monetary_account_id_fallback: Optional[int] = Field(
        None,
        description='ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.',
    )
    order_status: Optional[str] = Field(
        None,
        description='The order status to set for the card. Set to CARD_REQUEST_PENDING to get a virtual card produced.',
    )
    pin_code: Optional[str] = Field(
        None,
        description='The plaintext pin code. Requests require encryption to be enabled.',
    )
    pin_code_assignment: Optional[List[CardPinAssignment]] = Field(
        None, description='Array of Types, PINs, account IDs assigned to the card.'
    )
    primary_account_numbers: Optional[List[CardPrimaryAccountNumber]] = Field(
        None, description='Array of PANs and their attributes.'
    )
    status: Optional[str] = Field(
        None,
        description='The status to set for the card. Can be ACTIVE, DEACTIVATED, LOST, STOLEN or CANCELLED, and can only be set to LOST/STOLEN/CANCELLED when order status is ACCEPTED_FOR_PRODUCTION/DELIVERED_TO_CUSTOMER/CARD_UPDATE_REQUESTED/CARD_UPDATE_SENT/CARD_UPDATE_ACCEPTED. Can only be set to DEACTIVATED after initial activation, i.e. order_status is DELIVERED_TO_CUSTOMER/CARD_UPDATE_REQUESTED/CARD_UPDATE_SENT/CARD_UPDATE_ACCEPTED. Mind that all the possible choices (apart from ACTIVE and DEACTIVATED) are permanent and cannot be changed after.',
    )


class CardBatchEntry(BaseModel):
    card_limit: Optional[Amount] = Field(
        None, description='The spending limit for the card.'
    )
    card_limit_atm: Optional[Amount] = Field(
        None, description='The ATM spending limit for the card.'
    )
    country_permission: Optional[List[CardCountryPermission]] = Field(
        None,
        description='The countries for which to grant (temporary) permissions to use the card.',
    )
    id: int = Field(..., description='The ID of the card that needs to be updated.')
    monetary_account_id_fallback: Optional[int] = Field(
        None,
        description='ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.',
    )
    status: Optional[str] = Field(
        None,
        description='The status to set for the card. Can be ACTIVE, DEACTIVATED, LOST, STOLEN or CANCELLED, and can only be set to LOST/STOLEN/CANCELLED when order status is ACCEPTED_FOR_PRODUCTION/DELIVERED_TO_CUSTOMER/CARD_UPDATE_REQUESTED/CARD_UPDATE_SENT/CARD_UPDATE_ACCEPTED. Can only be set to DEACTIVATED after initial activation, i.e. order_status is DELIVERED_TO_CUSTOMER/CARD_UPDATE_REQUESTED/CARD_UPDATE_SENT/CARD_UPDATE_ACCEPTED. Mind that all the possible choices (apart from ACTIVE and DEACTIVATED) are permanent and cannot be changed after.',
    )


class CardBatchReplaceEntry(BaseModel):
    id: int = Field(..., description='The ID of the card that needs to be replaced.')
    name_on_card: Optional[str] = Field(
        None,
        description="The user's name as it will be on the card. Check 'card-name' for the available card names for a user.",
    )
    pin_code_assignment: Optional[List[CardPinAssignment]] = Field(
        None, description='Array of Types, PINs, account IDs assigned to the card.'
    )
    second_line: Optional[str] = Field(None, description='The second line on the card.')


class CardCredit(BaseModel):
    alias: Optional[Pointer] = Field(
        None,
        description='The pointer to the monetary account that will be connected at first with the card. Its IBAN code is also the one that will be printed on the card itself. The pointer must be of type IBAN.',
    )
    monetary_account_id_fallback: Optional[int] = Field(
        None,
        description='ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.',
    )
    name_on_card: str = Field(
        ...,
        description="The user's name as it will be on the card. Check 'card-name' for the available card names for a user.",
    )
    order_status: Optional[str] = Field(
        None,
        description='The order status of this card. Can be CARD_REQUEST_PENDING or VIRTUAL_DELIVERY.',
    )
    pin_code_assignment: Optional[List[CardPinAssignment]] = Field(
        None, description='Array of Types, PINs, account IDs assigned to the card.'
    )
    preferred_name_on_card: Optional[str] = Field(
        None, description="The user's preferred name that can be put on the card."
    )
    product_type: str = Field(..., description='The product type of the card to order.')
    second_line: str = Field(
        ...,
        description='The second line of text on the card, used as name/description for it. It can contain at most 17 characters and it can be empty.',
    )
    type: str = Field(..., description='The type of card to order. Can be MASTERCARD.')


class CardDebit(BaseModel):
    alias: Optional[Pointer] = Field(
        None,
        description='The pointer to the monetary account that will be connected at first with the card. Its IBAN code is also the one that will be printed on the card itself. The pointer must be of type IBAN.',
    )
    monetary_account_id_fallback: Optional[int] = Field(
        None,
        description='ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.',
    )
    name_on_card: str = Field(
        ...,
        description="The user's name as it will be on the card. Check 'card-name' for the available card names for a user.",
    )
    order_status: Optional[str] = Field(
        None,
        description='The order status of this card. Can be CARD_REQUEST_PENDING or VIRTUAL_DELIVERY.',
    )
    pin_code_assignment: Optional[List[CardPinAssignment]] = Field(
        None, description='Array of Types, PINs, account IDs assigned to the card.'
    )
    preferred_name_on_card: Optional[str] = Field(
        None, description="The user's preferred name that can be put on the card."
    )
    product_type: str = Field(..., description='The product type of the card to order.')
    second_line: str = Field(
        ...,
        description='The second line of text on the card, used as name/description for it. It can contain at most 17 characters and it can be empty.',
    )
    type: str = Field(
        ..., description='The type of card to order. Can be MAESTRO or MASTERCARD.'
    )


class Company(BaseModel):
    address_main: Address = Field(..., description="The company's main address.")
    address_postal: Address = Field(..., description="The company's postal address.")
    avatar_uuid: Optional[str] = Field(
        None, description="The public UUID of the company's avatar."
    )
    chamber_of_commerce_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )
    country: str = Field(
        ..., description='The country where the company is registered.'
    )
    legal_form: str = Field(..., description="The company's legal form.")
    name: str = Field(..., description='The company name.')
    signup_track_type: Optional[str] = Field(
        None, description='The type of signup track the user is following.'
    )
    subscription_type: str = Field(
        ..., description='The subscription type for the company.'
    )
    ubo: Optional[List[Ubo]] = Field(
        None,
        description="The names and birth dates of the company's ultimate beneficiary owners. Minimum zero, maximum four.",
    )
    vat_number: Optional[CompanyVatNumber] = Field(
        None, description='All the vat numbers of the company'
    )


class ConfirmationOfFunds(BaseModel):
    amount: Amount = Field(..., description='The amount we want to check for.')
    pointer_iban: Pointer = Field(
        ..., description="The pointer (IBAN) of the account we're querying."
    )


class CurrencyCloudPaymentQuote(BaseModel):
    pointers: List[Pointer] = Field(
        ..., description='The points we want to know the fees for.'
    )


class CurrencyConversionQuote(BaseModel):
    amount: Amount = Field(..., description='The amount to convert.')
    counterparty_alias: Pointer = Field(
        ..., description='The Alias of the party we are transferring the money to.'
    )
    currency_source: str = Field(..., description='The currency we are converting.')
    currency_target: str = Field(
        ..., description='The currency we are converting towards.'
    )
    status: Optional[str] = Field(None, description='The status of the quote.')


class DeviceListing(BaseModel):
    DeviceServer_1: Optional[DeviceServer] = Field(
        None, alias='DeviceServer', description=''
    )


class DeviceRead(BaseModel):
    DeviceServer_1: Optional[DeviceServer] = Field(
        None, alias='DeviceServer', description=''
    )


class FeatureAnnouncement(BaseModel):
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the event overview.'
    )
    sub_title: Optional[str] = Field(
        None, description='The event overview subtitle of the feature display'
    )
    title: Optional[str] = Field(
        None, description='The event overview title of the feature display'
    )
    type: Optional[str] = Field(
        None,
        description='The type of the feature announcement so apps can override with their own stuff if desired',
    )


class FeatureAnnouncementRead(BaseModel):
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the event overview.'
    )
    sub_title: Optional[str] = Field(
        None, description='The event overview subtitle of the feature display'
    )
    title: Optional[str] = Field(
        None, description='The event overview title of the feature display'
    )
    type: Optional[str] = Field(
        None,
        description='The type of the feature announcement so apps can override with their own stuff if desired',
    )


class InstallationCreate(BaseModel):
    Id: Optional[BunqId] = Field(
        None, description='The Id object of the created Installation'
    )
    ServerPublicKey: Optional[InstallationServerPublicKey] = Field(
        None, description='The ServerPublicKey object of the created Installation'
    )
    Token: Optional[InstallationToken] = Field(
        None, description='The Token object of this Installation.'
    )


class LabelUser(BaseModel):
    avatar: Optional[Avatar] = Field(
        None, description='The current avatar of the user.'
    )
    country: Optional[str] = Field(
        None, description='The country of the user. 000 stands for "unknown"'
    )
    display_name: Optional[str] = Field(
        None,
        description='The name to be displayed for this user, as it was given on the request.',
    )
    public_nick_name: Optional[str] = Field(
        None, description='The current nickname of the user.'
    )
    uuid: Optional[str] = Field(None, description='The public UUID of the label-user.')


class MonetaryAccountBank(BaseModel):
    avatar_uuid: Optional[str] = Field(
        None, description='The UUID of the Avatar of the MonetaryAccountBank.'
    )
    country_iban: Optional[str] = Field(
        None, description='The country of the monetary account IBAN.'
    )
    currency: str = Field(
        ...,
        description='The currency of the MonetaryAccountBank as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountBank. Defaults to 1000 EUR. Currency must match the MonetaryAccountBank's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountBank. Defaults to 'bunq account'.",
    )
    display_name: Optional[str] = Field(
        None,
        description='The legal name of the user / company using this monetary account.',
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountBank, can only be OTHER. Should only be specified if updating the status to CANCELLED.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountBank. Can be any user provided message. Should only be specified if updating the status to CANCELLED.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountBank.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountBank. Ignored in POST requests (always set to ACTIVE) can be CANCELLED or PENDING_REOPEN in PUT requests to cancel (close) or reopen the MonetaryAccountBank. When updating the status and/or sub_status no other fields can be updated in the same request (and vice versa).',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountBank providing extra information regarding the status. Should be ignored for POST requests. In case of PUT requests with status CANCELLED it can only be REDEMPTION_VOLUNTARY, while with status PENDING_REOPEN it can only be NONE. When updating the status and/or sub_status no other fields can be updated in the same request (and vice versa).',
    )


class MonetaryAccountLight(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountLight.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountLight.'
    )
    avatar_uuid: Optional[str] = Field(
        None, description='The UUID of the Avatar of the MonetaryAccountLight.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountLight.',
    )
    balance_maximum: Optional[Amount] = Field(
        None, description='The maximum balance Amount of the MonetaryAccountLight.'
    )
    budget_month_maximum: Optional[Amount] = Field(
        None, description='The total amount of the monthly budget.'
    )
    budget_month_used: Optional[Amount] = Field(
        None, description='The amount of the monthly budget used.'
    )
    budget_withdrawal_year_maximum: Optional[Amount] = Field(
        None, description='The total amount of the yearly withdrawal budget.'
    )
    budget_withdrawal_year_used: Optional[Amount] = Field(
        None, description='The amount of the yearly withdrawal budget used.'
    )
    budget_year_maximum: Optional[Amount] = Field(
        None, description='The total amount of the yearly budget.'
    )
    budget_year_used: Optional[Amount] = Field(
        None, description='The amount of the yearly budget used.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountLight's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountLight as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountLight. Defaults to 1000 EUR. Currency must match the MonetaryAccountLight's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountLight. Defaults to 'bunq account'.",
    )
    id: Optional[int] = Field(None, description='The id of the MonetaryAccountLight.')
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountLight's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountBank, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountBank. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountLight.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountLight. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountLight providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountLight's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountLight.'
    )


class NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentBunqMeFundraiserResultListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentBunqMeFundraiserResultRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentDraftPaymentListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentDraftPaymentRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentIdealMerchantTransactionListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentIdealMerchantTransactionRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentMasterCardActionListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentMasterCardActionRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentPaymentBatchListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentPaymentBatchRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentPaymentListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentPaymentRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentRequestInquiryBatchListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentRequestInquiryBatchRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentRequestInquiryListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentRequestInquiryRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentRequestResponseListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentRequestResponseRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentScheduleInstanceListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentScheduleInstanceRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentSchedulePaymentBatchListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentSchedulePaymentBatchRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentSchedulePaymentListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentSchedulePaymentRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentSofortMerchantTransactionListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentSofortMerchantTransactionRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentWhitelistResultListing(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteAttachmentWhitelistResultRead(BaseModel):
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The attachment attached to the note.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    description: Optional[str] = Field(
        None, description='Optional description of the attachment.'
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextBankSwitchServiceNetherlandsIncomingPaymentRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextBunqMeFundraiserResultListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextBunqMeFundraiserResultRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextDraftPaymentListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextDraftPaymentRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextIdealMerchantTransactionListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextIdealMerchantTransactionRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextMasterCardActionListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextMasterCardActionRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextPaymentBatchListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextPaymentBatchRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextPaymentListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextPaymentRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextRequestInquiryBatchListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextRequestInquiryBatchRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextRequestInquiryListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextRequestInquiryRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextRequestResponseListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextRequestResponseRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextScheduleInstanceListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextScheduleInstanceRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextSchedulePaymentBatchListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextSchedulePaymentBatchRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextSchedulePaymentListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextSchedulePaymentRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextSofortMerchantTransactionListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextSofortMerchantTransactionRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextWhitelistResultListing(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class NoteTextWhitelistResultRead(BaseModel):
    content: Optional[str] = Field(None, description='The content of the note.')
    created: Optional[str] = Field(
        None, description="The timestamp of the note's creation."
    )
    id: Optional[int] = Field(None, description='The id of the note.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the note's last update."
    )


class PaymentAutoAllocateDefinition(BaseModel):
    amount: Optional[Amount] = Field(None, description='The amount to allocate.')
    counterparty_alias: Optional[Pointer] = Field(
        None, description='The alias of the party we are allocating the money to.'
    )
    created: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateDefinition was created.',
    )
    description: Optional[str] = Field(
        None, description='The description for the payment.'
    )
    fraction: Optional[int] = Field(
        None,
        description="The percentage of the triggering payment's amount to allocate.",
    )
    id: Optional[int] = Field(
        None, description='The id of the PaymentAutoAllocateDefinition.'
    )
    type: str = Field(..., description='The type of definition.')
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateDefinition was last updated.',
    )


class PaymentAutoAllocateDefinitionListing(BaseModel):
    amount: Optional[Amount] = Field(None, description='The amount to allocate.')
    counterparty_alias: Optional[Pointer] = Field(
        None, description='The alias of the party we are allocating the money to.'
    )
    created: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateDefinition was created.',
    )
    description: Optional[str] = Field(
        None, description='The description for the payment.'
    )
    fraction: Optional[int] = Field(
        None,
        description="The percentage of the triggering payment's amount to allocate.",
    )
    id: Optional[int] = Field(
        None, description='The id of the PaymentAutoAllocateDefinition.'
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateDefinition was last updated.',
    )


class PaymentServiceProviderCredentialRead(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the credential object's creation."
    )
    expiry_time: Optional[str] = Field(
        None,
        description='When the status is PENDING_FIRST_USE: when the credential expires.',
    )
    id: Optional[int] = Field(None, description='The id of the credential.')
    permitted_device: Optional[PermittedDevice] = Field(
        None,
        description='When the status is ACTIVE: the details of the device that may use the credential.',
    )
    status: Optional[str] = Field(None, description='The status of the credential.')
    token_value: Optional[str] = Field(
        None,
        description='When the status is PENDING_FIRST_USE: the value of the token.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the credential object's last update."
    )


class RelationUser(BaseModel):
    counter_label_user: Optional[LabelUser] = Field(
        None, description="The counter user's label."
    )
    counter_user_id: Optional[str] = Field(None, description="The counter user's ID.")
    counter_user_status: Optional[str] = Field(
        None, description='The account status of a user'
    )
    label_user: Optional[LabelUser] = Field(None, description="The user's label.")
    relationship: Optional[str] = Field(
        None, description='The requested relation type.'
    )
    status: Optional[str] = Field(
        None, description="The request's status, only for UPDATE."
    )
    user_id: Optional[str] = Field(None, description="The user's ID.")
    user_status: Optional[str] = Field(None, description='The account status of a user')


class RewardListing(BaseModel):
    amount_reward: Optional[Amount] = Field(
        None,
        description='The amount that will be/was awarded as reward for the reward.',
    )
    counterparty_alias: Optional[LabelUser] = Field(
        None, description='The alias of the other user eligible for the reward award.'
    )
    created: Optional[str] = Field(None, description='The time the reward was created.')
    id: Optional[int] = Field(None, description='The id of the reward.')
    status: Optional[str] = Field(None, description='The status of the reward.')
    sub_status: Optional[str] = Field(None, description='The subStatus of the reward.')
    type: Optional[str] = Field(None, description='The type of the reward.')
    updated: Optional[str] = Field(
        None, description='The time the reward was last updated.'
    )


class RewardRead(BaseModel):
    amount_reward: Optional[Amount] = Field(
        None,
        description='The amount that will be/was awarded as reward for the reward.',
    )
    counterparty_alias: Optional[LabelUser] = Field(
        None, description='The alias of the other user eligible for the reward award.'
    )
    created: Optional[str] = Field(None, description='The time the reward was created.')
    id: Optional[int] = Field(None, description='The id of the reward.')
    status: Optional[str] = Field(None, description='The status of the reward.')
    sub_status: Optional[str] = Field(None, description='The subStatus of the reward.')
    type: Optional[str] = Field(None, description='The type of the reward.')
    updated: Optional[str] = Field(
        None, description='The time the reward was last updated.'
    )


class RewardRecipient(BaseModel):
    amount_reward: Optional[Amount] = Field(
        None,
        description='The amount that will be/was awarded as reward for the reward.',
    )
    counterparty_alias: Optional[LabelUser] = Field(
        None, description='The alias of the other user eligible for the reward award.'
    )
    created: Optional[str] = Field(None, description='The time the reward was created.')
    id: Optional[int] = Field(None, description='The id of the reward.')
    status: Optional[str] = Field(None, description='The status of the reward.')
    sub_status: Optional[str] = Field(None, description='The subStatus of the reward.')
    type: Optional[str] = Field(None, description='The type of the reward.')
    updated: Optional[str] = Field(
        None, description='The time the reward was last updated.'
    )


class RewardRecipientListing(BaseModel):
    amount_reward: Optional[Amount] = Field(
        None,
        description='The amount that will be/was awarded as reward for the reward.',
    )
    counterparty_alias: Optional[LabelUser] = Field(
        None, description='The alias of the other user eligible for the reward award.'
    )
    created: Optional[str] = Field(None, description='The time the reward was created.')
    id: Optional[int] = Field(None, description='The id of the reward.')
    status: Optional[str] = Field(None, description='The status of the reward.')
    sub_status: Optional[str] = Field(None, description='The subStatus of the reward.')
    type: Optional[str] = Field(None, description='The type of the reward.')
    updated: Optional[str] = Field(
        None, description='The time the reward was last updated.'
    )


class RewardRecipientRead(BaseModel):
    amount_reward: Optional[Amount] = Field(
        None,
        description='The amount that will be/was awarded as reward for the reward.',
    )
    counterparty_alias: Optional[LabelUser] = Field(
        None, description='The alias of the other user eligible for the reward award.'
    )
    created: Optional[str] = Field(None, description='The time the reward was created.')
    id: Optional[int] = Field(None, description='The id of the reward.')
    status: Optional[str] = Field(None, description='The status of the reward.')
    sub_status: Optional[str] = Field(None, description='The subStatus of the reward.')
    type: Optional[str] = Field(None, description='The type of the reward.')
    updated: Optional[str] = Field(
        None, description='The time the reward was last updated.'
    )


class RewardSender(BaseModel):
    amount_reward: Optional[Amount] = Field(
        None,
        description='The amount that will be/was awarded as reward for the reward.',
    )
    counterparty_alias: Optional[LabelUser] = Field(
        None, description='The alias of the other user eligible for the reward award.'
    )
    created: Optional[str] = Field(None, description='The time the reward was created.')
    id: Optional[int] = Field(None, description='The id of the reward.')
    status: Optional[str] = Field(None, description='The status of the reward.')
    sub_status: Optional[str] = Field(None, description='The subStatus of the reward.')
    type: Optional[str] = Field(None, description='The type of the reward.')
    updated: Optional[str] = Field(
        None, description='The time the reward was last updated.'
    )


class RewardSenderListing(BaseModel):
    amount_reward: Optional[Amount] = Field(
        None,
        description='The amount that will be/was awarded as reward for the reward.',
    )
    counterparty_alias: Optional[LabelUser] = Field(
        None, description='The alias of the other user eligible for the reward award.'
    )
    created: Optional[str] = Field(None, description='The time the reward was created.')
    id: Optional[int] = Field(None, description='The id of the reward.')
    status: Optional[str] = Field(None, description='The status of the reward.')
    sub_status: Optional[str] = Field(None, description='The subStatus of the reward.')
    type: Optional[str] = Field(None, description='The type of the reward.')
    updated: Optional[str] = Field(
        None, description='The time the reward was last updated.'
    )


class RewardSenderRead(BaseModel):
    amount_reward: Optional[Amount] = Field(
        None,
        description='The amount that will be/was awarded as reward for the reward.',
    )
    counterparty_alias: Optional[LabelUser] = Field(
        None, description='The alias of the other user eligible for the reward award.'
    )
    created: Optional[str] = Field(None, description='The time the reward was created.')
    id: Optional[int] = Field(None, description='The id of the reward.')
    status: Optional[str] = Field(None, description='The status of the reward.')
    sub_status: Optional[str] = Field(None, description='The subStatus of the reward.')
    type: Optional[str] = Field(None, description='The type of the reward.')
    updated: Optional[str] = Field(
        None, description='The time the reward was last updated.'
    )


class ShareDetail(BaseModel):
    draft_payment: Optional[ShareDetailDraftPayment] = Field(
        None,
        description="The share details for a draft payment share. In the response 'draft_payment' is replaced by 'ShareDetailDraftPayment'.",
    )
    payment: Optional[ShareDetailPayment] = Field(
        None,
        description="The share details for a payment share. In the response 'payment' is replaced by 'ShareDetailPayment'.",
    )
    read_only: Optional[ShareDetailReadOnly] = Field(
        None,
        description="The share details for viewing a share. In the response 'read_only' is replaced by 'ShareDetailReadOnly'.",
    )


class TransferwiseRequirementFieldGroupValidationAsync(BaseModel):
    params: Optional[TransferwiseRequirementFieldGroupValidationAsyncParams] = Field(
        None, description='The parameters to send when validating user input.'
    )
    url: Optional[str] = Field(
        None, description='The url to be used to validate user input.'
    )


class TreeProgressListing(BaseModel):
    label_user: Optional[LabelUser] = Field(
        None, description='The label of the user the progress belongs to.'
    )
    number_of_tree: Optional[int] = Field(
        None, description='The number of trees this user and all users have planted.'
    )
    progress_tree_next: Optional[int] = Field(
        None, description='The progress towards the next tree.'
    )
    url_invite_profile: Optional[str] = Field(
        None, description='URL of the invite profile.'
    )


class UserCompany(BaseModel):
    address_main: Optional[Address] = Field(
        None, description="The company's main address."
    )
    address_postal: Optional[Address] = Field(
        None, description="The company's postal address."
    )
    alias: Optional[List[Pointer]] = Field(
        None, description='The aliases of the account.'
    )
    avatar: Optional[Avatar] = Field(None, description="The company's avatar.")
    avatar_uuid: Optional[str] = Field(
        None, description="The public UUID of the company's avatar."
    )
    billing_contract: Optional[List[BillingContractSubscription]] = Field(
        None, description='The subscription of the company.'
    )
    chamber_of_commerce_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )
    counter_bank_iban: Optional[str] = Field(
        None,
        description="The company's other bank account IBAN, through which we verify it.",
    )
    country: Optional[str] = Field(
        None, description='The country as an ISO 3166-1 alpha-2 country code.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the company object's creation."
    )
    customer: Optional[Customer] = Field(
        None, description='The customer profile of the company.'
    )
    customer_limit: Optional[CustomerLimit] = Field(
        None, description='The customer limits of the company.'
    )
    daily_limit_without_confirmation_login: Optional[Amount] = Field(
        None,
        description='The amount the company can pay in the session without asking for credentials.',
    )
    deny_reason: Optional[str] = Field(None, description='The user deny reason.')
    directors: Optional[List[LabelUser]] = Field(
        None, description="The existing bunq aliases for the company's directors."
    )
    display_name: Optional[str] = Field(None, description="The company's display name.")
    id: Optional[int] = Field(None, description='The id of the modified company.')
    language: Optional[str] = Field(
        None,
        description="The person's preferred language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.",
    )
    legal_form: Optional[str] = Field(None, description="The company's legal form.")
    name: Optional[str] = Field(None, description='The company name.')
    notification_filters: Optional[List[NotificationFilter]] = Field(
        None,
        description='The types of notifications that will result in a push notification or URL callback for this UserCompany.',
    )
    public_nick_name: Optional[str] = Field(
        None, description="The company's public nick name."
    )
    public_uuid: Optional[str] = Field(None, description="The company's public UUID.")
    region: Optional[str] = Field(
        None,
        description="The person's preferred region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.",
    )
    relations: Optional[List[RelationUser]] = Field(
        None, description='The relations for this user.'
    )
    sector_of_industry: Optional[str] = Field(
        None, description='The sector of industry.'
    )
    session_timeout: Optional[int] = Field(
        None,
        description='The setting for the session timeout of the company in seconds.',
    )
    status: Optional[str] = Field(
        None, description='The user status. Can be: ACTIVE, SIGNUP, RECOVERY.'
    )
    sub_status: Optional[str] = Field(
        None,
        description='The user sub-status. Can be: NONE, FACE_RESET, APPROVAL, APPROVAL_DIRECTOR, APPROVAL_PARENT, APPROVAL_SUPPORT, COUNTER_IBAN, IDEAL or SUBMIT.',
    )
    tax_resident: Optional[List[TaxResident]] = Field(
        None, description="The user's tax residence numbers for different countries."
    )
    type_of_business_entity: Optional[str] = Field(
        None, description='The type of business entity.'
    )
    ubo: Optional[List[Ubo]] = Field(
        None,
        description="The names of the company's ultimate beneficiary owners. Minimum zero, maximum four.",
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the company object's last update."
    )
    version_terms_of_service: Optional[str] = Field(
        None, description='The version of the terms of service accepted by the user.'
    )


class UserCompanyRead(BaseModel):
    address_main: Optional[Address] = Field(
        None, description="The company's main address."
    )
    address_postal: Optional[Address] = Field(
        None, description="The company's postal address."
    )
    alias: Optional[List[Pointer]] = Field(
        None, description='The aliases of the account.'
    )
    avatar: Optional[Avatar] = Field(None, description="The company's avatar.")
    billing_contract: Optional[List[BillingContractSubscription]] = Field(
        None, description='The subscription of the company.'
    )
    chamber_of_commerce_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )
    counter_bank_iban: Optional[str] = Field(
        None,
        description="The company's other bank account IBAN, through which we verify it.",
    )
    country: Optional[str] = Field(
        None, description='The country as an ISO 3166-1 alpha-2 country code.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the company object's creation."
    )
    customer: Optional[Customer] = Field(
        None, description='The customer profile of the company.'
    )
    customer_limit: Optional[CustomerLimit] = Field(
        None, description='The customer limits of the company.'
    )
    daily_limit_without_confirmation_login: Optional[Amount] = Field(
        None,
        description='The amount the company can pay in the session without asking for credentials.',
    )
    deny_reason: Optional[str] = Field(None, description='The user deny reason.')
    directors: Optional[List[LabelUser]] = Field(
        None, description="The existing bunq aliases for the company's directors."
    )
    display_name: Optional[str] = Field(None, description="The company's display name.")
    id: Optional[int] = Field(None, description='The id of the modified company.')
    language: Optional[str] = Field(
        None,
        description="The person's preferred language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.",
    )
    legal_form: Optional[str] = Field(None, description="The company's legal form.")
    name: Optional[str] = Field(None, description='The company name.')
    notification_filters: Optional[List[NotificationFilter]] = Field(
        None,
        description='The types of notifications that will result in a push notification or URL callback for this UserCompany.',
    )
    public_nick_name: Optional[str] = Field(
        None, description="The company's public nick name."
    )
    public_uuid: Optional[str] = Field(None, description="The company's public UUID.")
    region: Optional[str] = Field(
        None,
        description="The person's preferred region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.",
    )
    relations: Optional[List[RelationUser]] = Field(
        None, description='The relations for this user.'
    )
    sector_of_industry: Optional[str] = Field(
        None, description='The sector of industry.'
    )
    session_timeout: Optional[int] = Field(
        None,
        description='The setting for the session timeout of the company in seconds.',
    )
    status: Optional[str] = Field(
        None, description='The user status. Can be: ACTIVE, SIGNUP, RECOVERY.'
    )
    sub_status: Optional[str] = Field(
        None,
        description='The user sub-status. Can be: NONE, FACE_RESET, APPROVAL, APPROVAL_DIRECTOR, APPROVAL_PARENT, APPROVAL_SUPPORT, COUNTER_IBAN, IDEAL or SUBMIT.',
    )
    tax_resident: Optional[List[TaxResident]] = Field(
        None, description="The user's tax residence numbers for different countries."
    )
    type_of_business_entity: Optional[str] = Field(
        None, description='The type of business entity.'
    )
    ubo: Optional[List[Ubo]] = Field(
        None,
        description="The names of the company's ultimate beneficiary owners. Minimum zero, maximum four.",
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the company object's last update."
    )
    version_terms_of_service: Optional[str] = Field(
        None, description='The version of the terms of service accepted by the user.'
    )


class UserPaymentServiceProvider(BaseModel):
    alias: Optional[List[Pointer]] = Field(None, description='The aliases of the user.')
    avatar: Optional[Avatar] = Field(None, description="The user's avatar.")
    certificate_distinguished_name: Optional[str] = Field(
        None,
        description='The distinguished name from the certificate used to identify this user.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the user object's creation."
    )
    display_name: Optional[str] = Field(
        None, description='The display name for the provider.'
    )
    id: Optional[int] = Field(None, description='The id of the user.')
    language: Optional[str] = Field(
        None,
        description="The provider's language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.",
    )
    public_nick_name: Optional[str] = Field(
        None, description='The public nick name for the provider.'
    )
    public_uuid: Optional[str] = Field(None, description="The providers's public UUID.")
    region: Optional[str] = Field(
        None,
        description="The provider's region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.",
    )
    session_timeout: Optional[int] = Field(
        None, description='The setting for the session timeout of the user in seconds.'
    )
    status: Optional[str] = Field(
        None,
        description='The user status. The user status. Can be: ACTIVE, BLOCKED or DENIED.',
    )
    sub_status: Optional[str] = Field(
        None, description='The user sub-status. Can be: NONE'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the user object's last update."
    )


class UserPaymentServiceProviderRead(BaseModel):
    alias: Optional[List[Pointer]] = Field(None, description='The aliases of the user.')
    avatar: Optional[Avatar] = Field(None, description="The user's avatar.")
    certificate_distinguished_name: Optional[str] = Field(
        None,
        description='The distinguished name from the certificate used to identify this user.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the user object's creation."
    )
    display_name: Optional[str] = Field(
        None, description='The display name for the provider.'
    )
    id: Optional[int] = Field(None, description='The id of the user.')
    language: Optional[str] = Field(
        None,
        description="The provider's language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.",
    )
    public_nick_name: Optional[str] = Field(
        None, description='The public nick name for the provider.'
    )
    public_uuid: Optional[str] = Field(None, description="The providers's public UUID.")
    region: Optional[str] = Field(
        None,
        description="The provider's region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, separated by an underscore.",
    )
    session_timeout: Optional[int] = Field(
        None, description='The setting for the session timeout of the user in seconds.'
    )
    status: Optional[str] = Field(
        None,
        description='The user status. The user status. Can be: ACTIVE, BLOCKED or DENIED.',
    )
    sub_status: Optional[str] = Field(
        None, description='The user sub-status. Can be: NONE'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the user object's last update."
    )


class UserPerson(BaseModel):
    address_main: Optional[Address] = Field(
        None, description="The person's main address."
    )
    address_postal: Optional[Address] = Field(
        None, description="The person's postal address."
    )
    alias: Optional[List[Pointer]] = Field(None, description='The aliases of the user.')
    avatar: Optional[Avatar] = Field(None, description="The user's avatar.")
    avatar_uuid: Optional[str] = Field(
        None, description="The public UUID of the user's avatar."
    )
    country_of_birth: Optional[str] = Field(
        None,
        description="The person's country of birth. Formatted as a SO 3166-1 alpha-2 country code.",
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the person object's creation."
    )
    daily_limit_without_confirmation_login: Optional[Amount] = Field(
        None,
        description='The amount the user can pay in the session without asking for credentials.',
    )
    date_of_birth: Optional[str] = Field(
        None, description="The person's date of birth. Accepts ISO8601 date formats."
    )
    display_name: Optional[str] = Field(
        None, description='The display name for the person.'
    )
    document_back_attachment_id: Optional[int] = Field(
        None,
        description='The reference to the uploaded picture/scan of the back side of the identification document.',
    )
    document_country_of_issuance: Optional[str] = Field(
        None,
        description='The country which issued the identification document the person registered with.',
    )
    document_front_attachment_id: Optional[int] = Field(
        None,
        description='The reference to the uploaded picture/scan of the front side of the identification document.',
    )
    document_number: Optional[str] = Field(
        None,
        description='The identification document number the person registered with.',
    )
    document_type: Optional[str] = Field(
        None,
        description='The type of identification document the person registered with.',
    )
    first_name: Optional[str] = Field(None, description="The person's first name.")
    gender: Optional[str] = Field(
        None, description="The person's gender. Can be MALE, FEMALE or UNKNOWN."
    )
    id: Optional[int] = Field(None, description='The id of the modified person object.')
    language: Optional[str] = Field(
        None,
        description="The person's preferred language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.",
    )
    last_name: Optional[str] = Field(None, description="The person's last name.")
    legal_guardian_alias: Optional[Pointer] = Field(
        None, description='The legal guardian of the user. Required for minors.'
    )
    legal_name: Optional[str] = Field(None, description="The person's legal name.")
    middle_name: Optional[str] = Field(None, description="The person's middle name.")
    nationality: Optional[str] = Field(
        None,
        description="The person's nationality. Formatted as a SO 3166-1 alpha-2 country code.",
    )
    notification_filters: Optional[List[NotificationFilter]] = Field(
        None,
        description='The types of notifications that will result in a push notification or URL callback for this UserPerson.',
    )
    place_of_birth: Optional[str] = Field(
        None, description="The person's place of birth."
    )
    public_nick_name: Optional[str] = Field(
        None, description='The public nick name for the person.'
    )
    public_uuid: Optional[str] = Field(None, description="The person's public UUID.")
    region: Optional[str] = Field(
        None,
        description="The person's preferred region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.",
    )
    relations: Optional[List[RelationUser]] = Field(
        None, description='The relations for this user.'
    )
    session_timeout: Optional[int] = Field(
        None, description='The setting for the session timeout of the user in seconds.'
    )
    signup_track_type: Optional[str] = Field(
        None, description='The type of signup track the user is following.'
    )
    status: Optional[str] = Field(
        None,
        description='The user status. The user status. Can be: ACTIVE, BLOCKED, SIGNUP, RECOVERY, DENIED or ABORTED.',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The user sub-status. Can be: NONE, FACE_RESET, APPROVAL, APPROVAL_DIRECTOR, APPROVAL_PARENT, APPROVAL_SUPPORT, COUNTER_IBAN, IDEAL or SUBMIT.',
    )
    subscription_type: Optional[str] = Field(
        None, description='The subscription type the user should start on.'
    )
    tax_resident: Optional[List[TaxResident]] = Field(
        None, description="The user's tax residence numbers for different countries."
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the person object's last update."
    )
    version_terms_of_service: Optional[str] = Field(
        None, description='The version of the terms of service accepted by the user.'
    )


class UserPersonRead(BaseModel):
    address_main: Optional[Address] = Field(
        None, description="The person's main address."
    )
    address_postal: Optional[Address] = Field(
        None, description="The person's postal address."
    )
    alias: Optional[List[Pointer]] = Field(None, description='The aliases of the user.')
    avatar: Optional[Avatar] = Field(None, description="The user's avatar.")
    country_of_birth: Optional[str] = Field(
        None,
        description="The person's country of birth. Formatted as a SO 3166-1 alpha-2 country code.",
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the person object's creation."
    )
    daily_limit_without_confirmation_login: Optional[Amount] = Field(
        None,
        description='The amount the user can pay in the session without asking for credentials.',
    )
    date_of_birth: Optional[str] = Field(
        None, description="The person's date of birth. Accepts ISO8601 date formats."
    )
    display_name: Optional[str] = Field(
        None, description='The display name for the person.'
    )
    first_name: Optional[str] = Field(None, description="The person's first name.")
    gender: Optional[str] = Field(
        None, description="The person's gender. Can be MALE, FEMALE or UNKNOWN."
    )
    id: Optional[int] = Field(None, description='The id of the modified person object.')
    language: Optional[str] = Field(
        None,
        description="The person's preferred language. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.",
    )
    last_name: Optional[str] = Field(None, description="The person's last name.")
    legal_name: Optional[str] = Field(None, description="The person's legal name.")
    middle_name: Optional[str] = Field(None, description="The person's middle name.")
    nationality: Optional[str] = Field(
        None,
        description="The person's nationality. Formatted as a SO 3166-1 alpha-2 country code.",
    )
    notification_filters: Optional[List[NotificationFilter]] = Field(
        None,
        description='The types of notifications that will result in a push notification or URL callback for this UserPerson.',
    )
    place_of_birth: Optional[str] = Field(
        None, description="The person's place of birth."
    )
    public_nick_name: Optional[str] = Field(
        None, description='The public nick name for the person.'
    )
    public_uuid: Optional[str] = Field(None, description="The person's public UUID.")
    region: Optional[str] = Field(
        None,
        description="The person's preferred region. Formatted as a ISO 639-1 language code plus a ISO 3166-1 alpha-2 country code, seperated by an underscore.",
    )
    relations: Optional[List[RelationUser]] = Field(
        None, description='The relations for this user.'
    )
    session_timeout: Optional[int] = Field(
        None, description='The setting for the session timeout of the user in seconds.'
    )
    status: Optional[str] = Field(
        None,
        description='The user status. The user status. Can be: ACTIVE, BLOCKED, SIGNUP, RECOVERY, DENIED or ABORTED.',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The user sub-status. Can be: NONE, FACE_RESET, APPROVAL, APPROVAL_DIRECTOR, APPROVAL_PARENT, APPROVAL_SUPPORT, COUNTER_IBAN, IDEAL or SUBMIT.',
    )
    tax_resident: Optional[List[TaxResident]] = Field(
        None, description="The user's tax residence numbers for different countries."
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the person object's last update."
    )
    version_terms_of_service: Optional[str] = Field(
        None, description='The version of the terms of service accepted by the user.'
    )


class DeviceGetResponse(RootModel[List[DeviceListing]]):
    root: List[DeviceListing]


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentBunqMeFundraiserResultListing]]
):
    root: List[NoteAttachmentBunqMeFundraiserResultListing]


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeFundraiserResultBunqmeFundraiserResultIDNoteTextGetResponse(
    RootModel[List[NoteTextBunqMeFundraiserResultListing]]
):
    root: List[NoteTextBunqMeFundraiserResultListing]


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentDraftPaymentListing]]
):
    root: List[NoteAttachmentDraftPaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentDraftPaymentIDNoteTextGetResponse(
    RootModel[List[NoteTextDraftPaymentListing]]
):
    root: List[NoteTextDraftPaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentIdealMerchantTransactionListing]]
):
    root: List[NoteAttachmentIdealMerchantTransactionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionIdealMerchantTransactionIDNoteTextGetResponse(
    RootModel[List[NoteTextIdealMerchantTransactionListing]]
):
    root: List[NoteTextIdealMerchantTransactionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentMasterCardActionListing]]
):
    root: List[NoteAttachmentMasterCardActionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionMastercardActionIDNoteTextGetResponse(
    RootModel[List[NoteTextMasterCardActionListing]]
):
    root: List[NoteTextMasterCardActionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocatePaymentAutoAllocateIDDefinitionGetResponse(
    RootModel[List[PaymentAutoAllocateDefinitionListing]]
):
    root: List[PaymentAutoAllocateDefinitionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentPaymentBatchListing]]
):
    root: List[NoteAttachmentPaymentBatchListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchPaymentBatchIDNoteTextGetResponse(
    RootModel[List[NoteTextPaymentBatchListing]]
):
    root: List[NoteTextPaymentBatchListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentPaymentListing]]
):
    root: List[NoteAttachmentPaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentPaymentIDNoteTextGetResponse(
    RootModel[List[NoteTextPaymentListing]]
):
    root: List[NoteTextPaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentRequestInquiryBatchListing]]
):
    root: List[NoteAttachmentRequestInquiryBatchListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchRequestInquiryBatchIDNoteTextGetResponse(
    RootModel[List[NoteTextRequestInquiryBatchListing]]
):
    root: List[NoteTextRequestInquiryBatchListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentRequestInquiryListing]]
):
    root: List[NoteAttachmentRequestInquiryListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryRequestInquiryIDNoteTextGetResponse(
    RootModel[List[NoteTextRequestInquiryListing]]
):
    root: List[NoteTextRequestInquiryListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentRequestResponseListing]]
):
    root: List[NoteAttachmentRequestResponseListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseRequestResponseIDNoteTextGetResponse(
    RootModel[List[NoteTextRequestResponseListing]]
):
    root: List[NoteTextRequestResponseListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentSchedulePaymentBatchListing]]
):
    root: List[NoteAttachmentSchedulePaymentBatchListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentBatchSchedulePaymentBatchIDNoteTextGetResponse(
    RootModel[List[NoteTextSchedulePaymentBatchListing]]
):
    root: List[NoteTextSchedulePaymentBatchListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentSchedulePaymentListing]]
):
    root: List[NoteAttachmentSchedulePaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentSchedulePaymentIDNoteTextGetResponse(
    RootModel[List[NoteTextSchedulePaymentListing]]
):
    root: List[NoteTextSchedulePaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentScheduleInstanceListing]]
):
    root: List[NoteAttachmentScheduleInstanceListing]


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceScheduleInstanceIDNoteTextGetResponse(
    RootModel[List[NoteTextScheduleInstanceListing]]
):
    root: List[NoteTextScheduleInstanceListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentSofortMerchantTransactionListing]]
):
    root: List[NoteAttachmentSofortMerchantTransactionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionSofortMerchantTransactionIDNoteTextGetResponse(
    RootModel[List[NoteTextSofortMerchantTransactionListing]]
):
    root: List[NoteTextSofortMerchantTransactionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing]]
):
    root: List[NoteAttachmentBankSwitchServiceNetherlandsIncomingPaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSwitchServicePaymentSwitchServicePaymentIDNoteTextGetResponse(
    RootModel[List[NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing]]
):
    root: List[NoteTextBankSwitchServiceNetherlandsIncomingPaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteAttachmentGetResponse(
    RootModel[List[NoteAttachmentWhitelistResultListing]]
):
    root: List[NoteAttachmentWhitelistResultListing]


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistWhitelistIDWhitelistResultWhitelistResultIDNoteTextGetResponse(
    RootModel[List[NoteTextWhitelistResultListing]]
):
    root: List[NoteTextWhitelistResultListing]


class UserUserIDRewardGetResponse(RootModel[List[RewardListing]]):
    root: List[RewardListing]


class UserUserIDRewardRecipientGetResponse(RootModel[List[RewardRecipientListing]]):
    root: List[RewardRecipientListing]


class UserUserIDRewardSenderGetResponse(RootModel[List[RewardSenderListing]]):
    root: List[RewardSenderListing]


class UserUserIDTreeProgressGetResponse(RootModel[List[TreeProgressListing]]):
    root: List[TreeProgressListing]


class CardBatch(BaseModel):
    cards: List[CardBatchEntry] = Field(
        ..., description='The cards that need to be updated.'
    )


class CardBatchReplace(BaseModel):
    cards: List[CardBatchReplaceEntry] = Field(
        ..., description='The cards that need to be replaced.'
    )


class CoOwner(BaseModel):
    alias: Optional[LabelUser] = Field(None, description='The Alias of the co-owner.')
    status: Optional[str] = Field(
        None, description='Can be: ACCEPTED, REJECTED, PENDING or REVOKED'
    )


class CompanyListing(BaseModel):
    UserCompany_1: Optional[UserCompany] = Field(
        None, alias='UserCompany', description=''
    )


class CompanyRead(BaseModel):
    UserCompany_1: Optional[UserCompany] = Field(
        None, alias='UserCompany', description=''
    )


class DraftPaymentResponse(BaseModel):
    status: Optional[str] = Field(
        None, description='The status with which was responded.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user that responded to the DraftPayment.'
    )


class ExportAnnualOverviewListing(BaseModel):
    alias_user: Optional[LabelUser] = Field(
        None, description='The user to which this annual overview belongs.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the annual overview 's creation."
    )
    id: Optional[int] = Field(
        None, description='The id of the annual overview as created on the server.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the annual overview 's last update."
    )
    year: Optional[int] = Field(None, description='The year for which the overview is.')


class ExportAnnualOverviewRead(BaseModel):
    alias_user: Optional[LabelUser] = Field(
        None, description='The user to which this annual overview belongs.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the annual overview 's creation."
    )
    id: Optional[int] = Field(
        None, description='The id of the annual overview as created on the server.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the annual overview 's last update."
    )
    year: Optional[int] = Field(None, description='The year for which the overview is.')


class LabelCard(BaseModel):
    expiry_date: Optional[str] = Field(
        None, description='The date this card will expire.'
    )
    label_user: Optional[LabelUser] = Field(None, description='The owner of this card.')
    second_line: Optional[str] = Field(None, description='The second line on the card.')
    status: Optional[str] = Field(None, description='The status of the card.')
    type: Optional[str] = Field(None, description='The type of the card.')
    uuid: Optional[str] = Field(None, description='The public UUID.')


class LabelMonetaryAccount(BaseModel):
    avatar: Optional[Avatar] = Field(
        None, description='The avatar of the monetary account.'
    )
    bunq_me: Optional[Pointer] = Field(
        None, description='Bunq.me pointer with type and value.'
    )
    country: Optional[str] = Field(
        None,
        description='The country of the user. Formatted as a ISO 3166-1 alpha-2 country code.',
    )
    display_name: Optional[str] = Field(
        None, description='The name to display with this monetary account.'
    )
    iban: Optional[str] = Field(None, description='The IBAN of the monetary account.')
    is_light: Optional[bool] = Field(
        None, description='Whether or not the monetary account is light.'
    )
    label_user: Optional[LabelUser] = Field(
        None, description='The user this monetary account belongs to.'
    )
    merchant_category_code: Optional[str] = Field(
        None, description='The merchant category code.'
    )
    swift_account_number: Optional[str] = Field(
        None,
        description='The account number used for a SWIFT payment. May or may not be an IBAN.',
    )
    swift_bic: Optional[str] = Field(
        None, description='The BIC used for a SWIFT payment.'
    )
    transferwise_account_number: Optional[str] = Field(
        None,
        description='The account number used for a Transferwise payment. May or may not be an IBAN.',
    )
    transferwise_bank_code: Optional[str] = Field(
        None,
        description='The bank code used for a Transferwise payment. May or may not be a BIC.',
    )


class MasterCardActionRefund(BaseModel):
    additional_information: Optional[AdditionalInformation] = Field(
        None, description='All additional information provided by the user.'
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The monetary account label of the account that this action is created for.',
    )
    amount: Optional[Amount] = Field(None, description='The amount to refund.')
    attachment: Optional[List[AttachmentMasterCardActionRefund]] = Field(
        None, description='The Attachments to attach to the refund request.'
    )
    category: Optional[str] = Field(
        None, description='The category of the refund, required for chargeback.'
    )
    comment: Optional[str] = Field(None, description='Comment about the refund.')
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account label of the counterparty.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the refund's creation."
    )
    description: Optional[str] = Field(
        None, description='The description for this transaction to display.'
    )
    id: Optional[int] = Field(None, description='The id of the refund.')
    label_card: Optional[LabelCard] = Field(None, description='The label of the card.')
    label_user_creator: Optional[LabelUser] = Field(
        None, description='The label of the user who created this note.'
    )
    mastercard_action_id: Optional[int] = Field(
        None, description='The id of mastercard action being refunded.'
    )
    reason: Optional[str] = Field(
        None,
        description='The reason of the refund. Can be REFUND_EXPIRED_TRANSACTION, REFUND_REQUESTED, REFUND_MERCHANT, REFUND_CHARGEBACK.',
    )
    reference_mastercard_action_event: Optional[List[MasterCardActionReference]] = (
        Field(None, description='The reference to the object this refund applies to.')
    )
    status: Optional[str] = Field(
        None,
        description='The status of the refunded mastercard action. Can be AUTO_APPROVED, AUTO_APPROVED_WAITING_FOR_EXPIRY, PENDING_APPROVAL, APPROVED, REFUNDED, DENIED or FAILED',
    )
    status_description: Optional[str] = Field(
        None, description="Description of the refund's current status."
    )
    status_description_translated: Optional[str] = Field(
        None,
        description="Description of the refund's current status, translated in user's language.",
    )
    status_together_url: Optional[str] = Field(
        None, description="Together topic concerning the refund's current status."
    )
    sub_type: Optional[str] = Field(
        None,
        description='The sub type of this refund indicating whether the chargeback will be FULL or PARTIAL.',
    )
    terms_and_conditions: Optional[str] = Field(
        None,
        description='Proof that the user acknowledged the terms and conditions for chargebacks.',
    )
    time_refund: Optional[str] = Field(
        None, description='The time the refund will take place.'
    )
    type: Optional[str] = Field(
        None, description='Type of this refund. Can de REFUND or CHARGEBACK'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the refund's last update."
    )


class MasterCardIdentityCheckChallengeRequestUserRead(BaseModel):
    amount: Optional[str] = Field(None, description='The transaction amount.')
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account label of the counterparty.'
    )
    description: Optional[str] = Field(
        None,
        description='The description of the purchase. NULL if no description is given.',
    )
    event_id: Optional[int] = Field(
        None, description='The ID of the latest event for the identity check.'
    )
    expiry_time: Optional[str] = Field(
        None, description='When the identity check expires.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the secure code. Can be PENDING, ACCEPTED, REJECTED, EXPIRED.',
    )


class MonetaryAccountJoint(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None,
        description='The Aliases to add to MonetaryAccountJoint. Must all be confirmed first. Can mostly be ignored.',
    )
    all_co_owner: List[CoOwner] = Field(
        ..., description='The users the account will be joint with.'
    )
    avatar_uuid: Optional[str] = Field(
        None, description='The UUID of the Avatar of the MonetaryAccountJoint.'
    )
    currency: str = Field(
        ...,
        description='The currency of the MonetaryAccountJoint as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountJoint. Defaults to 1000 EUR. Currency must match the MonetaryAccountJoint's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountJoint. Defaults to 'bunq account'.",
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountJoint can be 'in the red'. Must be 0 EUR or omitted.",
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountJoint, can only be OTHER. Should only be specified if updating the status to CANCELLED.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountJoint. Can be any user provided message. Should only be specified if updating the status to CANCELLED.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountJoint.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountJoint. Ignored in POST requests (always set to ACTIVE) can be CANCELLED or PENDING_REOPEN in PUT requests to cancel (close) or reopen the MonetaryAccountJoint. When updating the status and/or sub_status no other fields can be updated in the same request (and vice versa).',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountJoint providing extra information regarding the status. Should be ignored for POST requests. In case of PUT requests with status CANCELLED it can only be REDEMPTION_VOLUNTARY, while with status PENDING_REOPEN it can only be NONE. When updating the status and/or sub_status no other fields can be updated in the same request (and vice versa).',
    )


class MonetaryAccountProfileDrain(BaseModel):
    balance_preferred: Optional[Amount] = Field(None, description='The goal balance.')
    balance_threshold_high: Optional[Amount] = Field(
        None, description='The high threshold balance.'
    )
    savings_account_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The savings monetary account.'
    )
    status: Optional[str] = Field(None, description='The status of the profile.')


class MonetaryAccountSavings(BaseModel):
    all_co_owner: Optional[List[CoOwner]] = Field(
        None, description='The users the account will be joint with.'
    )
    avatar_uuid: Optional[str] = Field(
        None, description='The UUID of the Avatar of the MonetaryAccountSavings.'
    )
    currency: str = Field(
        ...,
        description='The currency of the MonetaryAccountSavings as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountSavings. Defaults to 1000 EUR. Currency must match the MonetaryAccountSavings's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountSavings. Defaults to 'bunq account'.",
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountSavings, can only be OTHER. Should only be specified if updating the status to CANCELLED.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountSavings. Can be any user provided message. Should only be specified if updating the status to CANCELLED.',
    )
    savings_goal: Optional[Amount] = Field(
        None, description='The Savings Goal set for this MonetaryAccountSavings.'
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountSavings.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountSavings. Ignored in POST requests (always set to ACTIVE) can be CANCELLED or PENDING_REOPEN in PUT requests to cancel (close) or reopen the MonetaryAccountSavings. When updating the status and/or sub_status no other fields can be updated in the same request (and vice versa).',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountSavings providing extra information regarding the status. Should be ignored for POST requests. In case of PUT requests with status CANCELLED it can only be REDEMPTION_VOLUNTARY, while with status PENDING_REOPEN it can only be NONE. When updating the status and/or sub_status no other fields can be updated in the same request (and vice versa).',
    )


class PaymentAutoAllocate(BaseModel):
    definition: List[PaymentAutoAllocateDefinition] = Field(
        ..., description='The definition of how the money should be allocated.'
    )
    payment_id: int = Field(
        ...,
        description='The payment that should be used to define the triggers for the payment auto allocate.',
    )
    type: str = Field(
        ..., description='Whether a payment should be sorted ONCE or RECURRING.'
    )


class PaymentAutoAllocateUserListing(BaseModel):
    PaymentAutoAllocate_1: Optional[PaymentAutoAllocate] = Field(
        None, alias='PaymentAutoAllocate', description=''
    )


class RegistryMembership(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount of the user who belongs to this RegistryMembership.',
    )
    auto_add_card_transaction: Optional[str] = Field(
        None,
        description='The setting for for adding automatically card transactions to the registry.',
    )
    balance: Optional[Amount] = Field(
        None, description='The balance of this RegistryMembership.'
    )
    invitor: Optional[LabelUser] = Field(
        None, description='The label of the user that sent the invite.'
    )
    registry_id: Optional[int] = Field(None, description='The registry id.')
    registry_title: Optional[str] = Field(None, description='The registry title.')
    status: Optional[str] = Field(
        None, description='The status of the RegistryMembership.'
    )
    status_settlement: Optional[str] = Field(
        None,
        description='The status of the settlement of the Registry. Can be PENDING or SETTLED.',
    )
    total_amount_spent: Optional[Amount] = Field(
        None, description='The total amount spent of this RegistryMembership.'
    )
    uuid: Optional[str] = Field(None, description='The UUID of the membership.')


class RegistrySettlementItem(BaseModel):
    amount: Optional[Amount] = Field(
        None, description='The amount of the RegistrySettlementItem.'
    )
    membership_paying: Optional[RegistryMembership] = Field(
        None, description='The membership of the user that has to pay.'
    )
    membership_receiving: Optional[RegistryMembership] = Field(
        None, description='The membership of the user that will receive money.'
    )
    paying_user_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount of the user that has to pay the request.',
    )
    receiving_user_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount of the user that will receive the amount.',
    )


class RegistrySettlementListing(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the RegistrySettlement's creation."
    )
    id: Optional[int] = Field(None, description='The id of the RegistrySettlement.')
    items: Optional[List[RegistrySettlementItem]] = Field(
        None, description='List of RegistrySettlementItems'
    )
    membership_settled: Optional[RegistryMembership] = Field(
        None, description='The membership of the user that has settled the registry.'
    )
    number_of_entries: Optional[int] = Field(
        None,
        description="The number of RegistryEntry's associated with this RegistrySettlement.",
    )
    settled_by_alias: Optional[RegistryMembership] = Field(
        None, description='The membership of the user that settled the Registry.'
    )
    settlement_time: Optional[str] = Field(
        None, description="The timestamp of the Registry's settlement."
    )
    total_amount_spent: Optional[Amount] = Field(
        None, description='The total amount spent for the RegistrySettlement.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the RegistrySettlement's last update."
    )


class RegistrySettlementRead(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the RegistrySettlement's creation."
    )
    id: Optional[int] = Field(None, description='The id of the RegistrySettlement.')
    items: Optional[List[RegistrySettlementItem]] = Field(
        None, description='List of RegistrySettlementItems'
    )
    membership_settled: Optional[RegistryMembership] = Field(
        None, description='The membership of the user that has settled the registry.'
    )
    number_of_entries: Optional[int] = Field(
        None,
        description="The number of RegistryEntry's associated with this RegistrySettlement.",
    )
    settled_by_alias: Optional[RegistryMembership] = Field(
        None, description='The membership of the user that settled the Registry.'
    )
    settlement_time: Optional[str] = Field(
        None, description="The timestamp of the Registry's settlement."
    )
    total_amount_spent: Optional[Amount] = Field(
        None, description='The total amount spent for the RegistrySettlement.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the RegistrySettlement's last update."
    )


class RequestResponse(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='The billing address provided by the accepting user if an address was requested.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='The shipping address provided by the accepting user if an address was requested.',
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount this RequestResponse was received on.',
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested Amount.')
    amount_responded: Optional[Amount] = Field(
        None, description='The Amount the RequestResponse was accepted with.'
    )
    attachment: Optional[List[Attachment]] = Field(
        None, description='The Attachments attached to the RequestResponse.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount that is requesting money with this RequestResponse.',
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the Request Response was created.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None,
        description='The credit scheme id provided by the counterparty for DIRECT_DEBIT inquiries.',
    )
    description: Optional[str] = Field(
        None,
        description='The description for the RequestResponse provided by the requesting party. Maximum 9000 characters.',
    )
    eligible_whitelist_id: Optional[int] = Field(
        None, description='The whitelist id for this action or null.'
    )
    event_id: Optional[int] = Field(
        None, description='The ID of the latest event for the request.'
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The Geolocation where the RequestResponse was created.'
    )
    id: Optional[int] = Field(None, description='The id of the Request Response.')
    mandate_identifier: Optional[str] = Field(
        None,
        description='The mandate id provided by the counterparty for DIRECT_DEBIT inquiries.',
    )
    minimum_age: Optional[int] = Field(
        None,
        description='The minimum age the user accepting the RequestResponse must have.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the MonetaryAccount the RequestResponse was received on.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to after accepting or rejecting the Request.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    require_address: Optional[str] = Field(
        None, description='Whether or not an address must be provided on accept.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the RequestResponse. Can be ACCEPTED, PENDING, REJECTED, REFUND_REQUESTED, REFUNDED or REVOKED.',
    )
    sub_type: Optional[str] = Field(
        None,
        description='The subtype of the RequestInquiry. Can be ONCE or RECURRING for DIRECT_DEBIT RequestInquiries and NONE for all other.',
    )
    time_expiry: Optional[str] = Field(
        None,
        description='The timestamp of when the RequestResponse expired or will expire.',
    )
    time_refund_requested: Optional[str] = Field(
        None,
        description='The timestamp of when a refund request for the RequestResponse was claimed.',
    )
    time_refunded: Optional[str] = Field(
        None, description='The timestamp of when the RequestResponse was refunded.'
    )
    time_responded: Optional[str] = Field(
        None, description='The timestamp of when the RequestResponse was responded to.'
    )
    type: Optional[str] = Field(
        None,
        description='The type of the RequestInquiry. Can be DIRECT_DEBIT, DIRECT_DEBIT_B2B, IDEAL, SOFORT or INTERNAL.',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the Request Response was last updated (will be updated when chat messages are received).',
    )
    user_refund_requested: Optional[LabelUser] = Field(
        None, description='The label of the user that requested the refund.'
    )


class RequestResponseListing(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='The billing address provided by the accepting user if an address was requested.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='The shipping address provided by the accepting user if an address was requested.',
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount this RequestResponse was received on.',
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested Amount.')
    amount_responded: Optional[Amount] = Field(
        None, description='The Amount the RequestResponse was accepted with.'
    )
    attachment: Optional[List[Attachment]] = Field(
        None, description='The Attachments attached to the RequestResponse.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount that is requesting money with this RequestResponse.',
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the Request Response was created.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None,
        description='The credit scheme id provided by the counterparty for DIRECT_DEBIT inquiries.',
    )
    description: Optional[str] = Field(
        None,
        description='The description for the RequestResponse provided by the requesting party. Maximum 9000 characters.',
    )
    eligible_whitelist_id: Optional[int] = Field(
        None, description='The whitelist id for this action or null.'
    )
    event_id: Optional[int] = Field(
        None, description='The ID of the latest event for the request.'
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The Geolocation where the RequestResponse was created.'
    )
    id: Optional[int] = Field(None, description='The id of the Request Response.')
    mandate_identifier: Optional[str] = Field(
        None,
        description='The mandate id provided by the counterparty for DIRECT_DEBIT inquiries.',
    )
    minimum_age: Optional[int] = Field(
        None,
        description='The minimum age the user accepting the RequestResponse must have.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the MonetaryAccount the RequestResponse was received on.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to after accepting or rejecting the Request.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    require_address: Optional[str] = Field(
        None, description='Whether or not an address must be provided on accept.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the RequestResponse. Can be ACCEPTED, PENDING, REJECTED, REFUND_REQUESTED, REFUNDED or REVOKED.',
    )
    sub_type: Optional[str] = Field(
        None,
        description='The subtype of the RequestInquiry. Can be ONCE or RECURRING for DIRECT_DEBIT RequestInquiries and NONE for all other.',
    )
    time_expiry: Optional[str] = Field(
        None,
        description='The timestamp of when the RequestResponse expired or will expire.',
    )
    time_refund_requested: Optional[str] = Field(
        None,
        description='The timestamp of when a refund request for the RequestResponse was claimed.',
    )
    time_refunded: Optional[str] = Field(
        None, description='The timestamp of when the RequestResponse was refunded.'
    )
    time_responded: Optional[str] = Field(
        None, description='The timestamp of when the RequestResponse was responded to.'
    )
    type: Optional[str] = Field(
        None,
        description='The type of the RequestInquiry. Can be DIRECT_DEBIT, DIRECT_DEBIT_B2B, IDEAL, SOFORT or INTERNAL.',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the Request Response was last updated (will be updated when chat messages are received).',
    )
    user_refund_requested: Optional[LabelUser] = Field(
        None, description='The label of the user that requested the refund.'
    )


class RequestResponseRead(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='The billing address provided by the accepting user if an address was requested.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='The shipping address provided by the accepting user if an address was requested.',
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount this RequestResponse was received on.',
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested Amount.')
    amount_responded: Optional[Amount] = Field(
        None, description='The Amount the RequestResponse was accepted with.'
    )
    attachment: Optional[List[Attachment]] = Field(
        None, description='The Attachments attached to the RequestResponse.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount that is requesting money with this RequestResponse.',
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the Request Response was created.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None,
        description='The credit scheme id provided by the counterparty for DIRECT_DEBIT inquiries.',
    )
    description: Optional[str] = Field(
        None,
        description='The description for the RequestResponse provided by the requesting party. Maximum 9000 characters.',
    )
    eligible_whitelist_id: Optional[int] = Field(
        None, description='The whitelist id for this action or null.'
    )
    event_id: Optional[int] = Field(
        None, description='The ID of the latest event for the request.'
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The Geolocation where the RequestResponse was created.'
    )
    id: Optional[int] = Field(None, description='The id of the Request Response.')
    mandate_identifier: Optional[str] = Field(
        None,
        description='The mandate id provided by the counterparty for DIRECT_DEBIT inquiries.',
    )
    minimum_age: Optional[int] = Field(
        None,
        description='The minimum age the user accepting the RequestResponse must have.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the MonetaryAccount the RequestResponse was received on.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to after accepting or rejecting the Request.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    require_address: Optional[str] = Field(
        None, description='Whether or not an address must be provided on accept.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the RequestResponse. Can be ACCEPTED, PENDING, REJECTED, REFUND_REQUESTED, REFUNDED or REVOKED.',
    )
    sub_type: Optional[str] = Field(
        None,
        description='The subtype of the RequestInquiry. Can be ONCE or RECURRING for DIRECT_DEBIT RequestInquiries and NONE for all other.',
    )
    time_expiry: Optional[str] = Field(
        None,
        description='The timestamp of when the RequestResponse expired or will expire.',
    )
    time_refund_requested: Optional[str] = Field(
        None,
        description='The timestamp of when a refund request for the RequestResponse was claimed.',
    )
    time_refunded: Optional[str] = Field(
        None, description='The timestamp of when the RequestResponse was refunded.'
    )
    time_responded: Optional[str] = Field(
        None, description='The timestamp of when the RequestResponse was responded to.'
    )
    type: Optional[str] = Field(
        None,
        description='The type of the RequestInquiry. Can be DIRECT_DEBIT, DIRECT_DEBIT_B2B, IDEAL, SOFORT or INTERNAL.',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the Request Response was last updated (will be updated when chat messages are received).',
    )
    user_refund_requested: Optional[LabelUser] = Field(
        None, description='The label of the user that requested the refund.'
    )


class SchedulePaymentEntry(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    allow_bunqto: Optional[bool] = Field(
        None, description='Whether or not sending a bunq.to payment is allowed.'
    )
    amount: Optional[Amount] = Field(
        None,
        description='The Amount transferred by the Payment. Will be negative for outgoing Payments and positive for incoming Payments (relative to the MonetaryAccount indicated by monetary_account_id).',
    )
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The Attachments attached to the Payment.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the Payment.',
    )
    description: Optional[str] = Field(
        None,
        description='The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.',
    )
    merchant_reference: Optional[str] = Field(
        None,
        description='Optional data included with the Payment specific to the merchant.',
    )


class ShareInviteMonetaryAccountInquiry(BaseModel):
    access_type: Optional[str] = Field(
        None, description='Type of access that is in place.'
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description="The label of the monetary account that's being shared."
    )
    counter_user_alias: Optional[LabelUser] = Field(
        None, description='The label of the user to share with.'
    )
    draft_share_invite_bank_id: Optional[int] = Field(
        None,
        description='DEPRECATED: USE `access_type` INSTEAD | The id of the draft share invite bank.',
    )
    end_date: Optional[str] = Field(
        None,
        description='DEPRECATED: USE `access_type` INSTEAD | The expiration date of this share.',
    )
    id: Optional[int] = Field(
        None, description='The id of the newly created share invite.'
    )
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the monetary account the share applies to.'
    )
    relationship: Optional[str] = Field(
        None, description='The relationship: COMPANY_DIRECTOR, COMPANY_EMPLOYEE, etc'
    )
    share_detail: Optional[ShareDetail] = Field(
        None,
        description='DEPRECATED: USE `access_type` INSTEAD | The share details. Only one of these objects may be passed.',
    )
    share_type: Optional[str] = Field(
        None,
        description='DEPRECATED: USE `access_type` INSTEAD | The share type, either STANDARD or MUTUAL.',
    )
    start_date: Optional[str] = Field(
        None,
        description='DEPRECATED: USE `access_type` INSTEAD | The start date of this share.',
    )
    status: Optional[str] = Field(
        None, description='The status of the share. Can be ACTIVE, REVOKED, REJECTED.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the share.'
    )
    user_alias_revoked: Optional[LabelUser] = Field(
        None, description='The user who revoked the share.'
    )


class ShareInviteMonetaryAccountInquiryListing(BaseModel):
    access_type: Optional[str] = Field(
        None, description='Type of access that is in place.'
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description="The label of the monetary account that's being shared."
    )
    counter_user_alias: Optional[LabelUser] = Field(
        None, description='The label of the user to share with.'
    )
    id: Optional[int] = Field(
        None, description='The id of the newly created share invite.'
    )
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the monetary account the share applies to.'
    )
    relationship: Optional[str] = Field(
        None, description='The relationship: COMPANY_DIRECTOR, COMPANY_EMPLOYEE, etc'
    )
    status: Optional[str] = Field(
        None, description='The status of the share. Can be ACTIVE, REVOKED, REJECTED.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the share.'
    )
    user_alias_revoked: Optional[LabelUser] = Field(
        None, description='The user who revoked the share.'
    )


class ShareInviteMonetaryAccountInquiryRead(BaseModel):
    access_type: Optional[str] = Field(
        None, description='Type of access that is in place.'
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description="The label of the monetary account that's being shared."
    )
    counter_user_alias: Optional[LabelUser] = Field(
        None, description='The label of the user to share with.'
    )
    id: Optional[int] = Field(
        None, description='The id of the newly created share invite.'
    )
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the monetary account the share applies to.'
    )
    relationship: Optional[str] = Field(
        None, description='The relationship: COMPANY_DIRECTOR, COMPANY_EMPLOYEE, etc'
    )
    status: Optional[str] = Field(
        None, description='The status of the share. Can be ACTIVE, REVOKED, REJECTED.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the share.'
    )
    user_alias_revoked: Optional[LabelUser] = Field(
        None, description='The user who revoked the share.'
    )


class ShareInviteMonetaryAccountResponse(BaseModel):
    access_type: Optional[str] = Field(
        None,
        description='Type of access that is wanted, one of VIEW_BALANCE, VIEW_TRANSACTION, DRAFT_PAYMENT or FULL_TRANSIENT',
    )
    card_id: Optional[int] = Field(
        None,
        description='The card to link to the shared monetary account. Used only if share_detail is ShareDetailCardPayment.',
    )
    counter_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account and user who created the share.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp of the ShareInviteBankResponse creation.'
    )
    description: Optional[str] = Field(
        None,
        description='The description of this share. It is basically the monetary account description.',
    )
    draft_share_invite_bank_id: Optional[int] = Field(
        None, description='The id of the draft share invite bank.'
    )
    end_date: Optional[str] = Field(
        None, description='The expiration date of this share.'
    )
    id: Optional[int] = Field(
        None, description='The id of the ShareInviteBankResponse.'
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account the ACCEPTED share applies to. null otherwise.',
    )
    relation_user: Optional[RelationUser] = Field(
        None, description='All of the relation users towards this MA.'
    )
    share_detail: Optional[ShareDetail] = Field(None, description='The share details.')
    share_type: Optional[str] = Field(
        None, description='The share type, either STANDARD or MUTUAL.'
    )
    start_date: Optional[str] = Field(None, description='The start date of this share.')
    status: Optional[str] = Field(
        None, description='The status of the share. Can be ACTIVE, REVOKED, REJECTED.'
    )
    updated: Optional[str] = Field(
        None, description='The timestamp of the ShareInviteBankResponse last update.'
    )
    user_alias_cancelled: Optional[LabelUser] = Field(
        None,
        description='The user who cancelled the share if it has been revoked or rejected.',
    )


class ShareInviteMonetaryAccountResponseListing(BaseModel):
    access_type: Optional[str] = Field(
        None,
        description='Type of access that is wanted, one of VIEW_BALANCE, VIEW_TRANSACTION, DRAFT_PAYMENT or FULL_TRANSIENT',
    )
    counter_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account and user who created the share.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp of the ShareInviteBankResponse creation.'
    )
    description: Optional[str] = Field(
        None,
        description='The description of this share. It is basically the monetary account description.',
    )
    draft_share_invite_bank_id: Optional[int] = Field(
        None, description='The id of the draft share invite bank.'
    )
    end_date: Optional[str] = Field(
        None, description='The expiration date of this share.'
    )
    id: Optional[int] = Field(
        None, description='The id of the ShareInviteBankResponse.'
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account the ACCEPTED share applies to. null otherwise.',
    )
    relation_user: Optional[RelationUser] = Field(
        None, description='All of the relation users towards this MA.'
    )
    share_detail: Optional[ShareDetail] = Field(None, description='The share details.')
    share_type: Optional[str] = Field(
        None, description='The share type, either STANDARD or MUTUAL.'
    )
    start_date: Optional[str] = Field(None, description='The start date of this share.')
    status: Optional[str] = Field(
        None, description='The status of the share. Can be ACTIVE, REVOKED, REJECTED.'
    )
    updated: Optional[str] = Field(
        None, description='The timestamp of the ShareInviteBankResponse last update.'
    )
    user_alias_cancelled: Optional[LabelUser] = Field(
        None,
        description='The user who cancelled the share if it has been revoked or rejected.',
    )


class ShareInviteMonetaryAccountResponseRead(BaseModel):
    access_type: Optional[str] = Field(
        None,
        description='Type of access that is wanted, one of VIEW_BALANCE, VIEW_TRANSACTION, DRAFT_PAYMENT or FULL_TRANSIENT',
    )
    counter_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account and user who created the share.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp of the ShareInviteBankResponse creation.'
    )
    description: Optional[str] = Field(
        None,
        description='The description of this share. It is basically the monetary account description.',
    )
    draft_share_invite_bank_id: Optional[int] = Field(
        None, description='The id of the draft share invite bank.'
    )
    end_date: Optional[str] = Field(
        None, description='The expiration date of this share.'
    )
    id: Optional[int] = Field(
        None, description='The id of the ShareInviteBankResponse.'
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account the ACCEPTED share applies to. null otherwise.',
    )
    relation_user: Optional[RelationUser] = Field(
        None, description='All of the relation users towards this MA.'
    )
    share_detail: Optional[ShareDetail] = Field(None, description='The share details.')
    share_type: Optional[str] = Field(
        None, description='The share type, either STANDARD or MUTUAL.'
    )
    start_date: Optional[str] = Field(None, description='The start date of this share.')
    status: Optional[str] = Field(
        None, description='The status of the share. Can be ACTIVE, REVOKED, REJECTED.'
    )
    updated: Optional[str] = Field(
        None, description='The timestamp of the ShareInviteBankResponse last update.'
    )
    user_alias_cancelled: Optional[LabelUser] = Field(
        None,
        description='The user who cancelled the share if it has been revoked or rejected.',
    )


class SofortMerchantTransaction(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account to add money to.'
    )
    amount_guaranteed: Optional[Amount] = Field(
        None,
        description='In case of a successful transaction, the amount of money that will be transferred.',
    )
    amount_requested: Optional[Amount] = Field(
        None, description='The requested amount of money to add.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account the money comes from.'
    )
    error_message: Optional[List[Error]] = Field(
        None, description='The error message of the transaction.'
    )
    issuer: Optional[str] = Field(None, description='The BIC of the issuer.')
    issuer_authentication_url: Optional[str] = Field(
        None, description='The URL to visit to '
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account this sofort merchant transaction links to.',
    )
    status: Optional[str] = Field(None, description='The status of the transaction.')
    transaction_identifier: Optional[str] = Field(
        None, description="The 'transaction ID' of the Sofort transaction."
    )


class SofortMerchantTransactionListing(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account to add money to.'
    )
    amount_guaranteed: Optional[Amount] = Field(
        None,
        description='In case of a successful transaction, the amount of money that will be transferred.',
    )
    amount_requested: Optional[Amount] = Field(
        None, description='The requested amount of money to add.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account the money comes from.'
    )
    error_message: Optional[List[Error]] = Field(
        None, description='The error message of the transaction.'
    )
    issuer: Optional[str] = Field(None, description='The BIC of the issuer.')
    issuer_authentication_url: Optional[str] = Field(
        None, description='The URL to visit to '
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account this sofort merchant transaction links to.',
    )
    status: Optional[str] = Field(None, description='The status of the transaction.')
    transaction_identifier: Optional[str] = Field(
        None, description="The 'transaction ID' of the Sofort transaction."
    )


class SofortMerchantTransactionRead(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account to add money to.'
    )
    amount_guaranteed: Optional[Amount] = Field(
        None,
        description='In case of a successful transaction, the amount of money that will be transferred.',
    )
    amount_requested: Optional[Amount] = Field(
        None, description='The requested amount of money to add.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account the money comes from.'
    )
    error_message: Optional[List[Error]] = Field(
        None, description='The error message of the transaction.'
    )
    issuer: Optional[str] = Field(None, description='The BIC of the issuer.')
    issuer_authentication_url: Optional[str] = Field(
        None, description='The URL to visit to '
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account this sofort merchant transaction links to.',
    )
    status: Optional[str] = Field(None, description='The status of the transaction.')
    transaction_identifier: Optional[str] = Field(
        None, description="The 'transaction ID' of the Sofort transaction."
    )


class TokenQrRequestIdealCreate(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='The billing address provided by the accepting user if an address was requested.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='The shipping address provided by the accepting user if an address was requested.',
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount this RequestResponse was received on.',
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested Amount.')
    amount_responded: Optional[Amount] = Field(
        None, description='The Amount the RequestResponse was accepted with.'
    )
    attachment: Optional[List[Attachment]] = Field(
        None, description='The Attachments attached to the RequestResponse.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount that is requesting money with this RequestResponse.',
    )
    description: Optional[str] = Field(
        None,
        description='The description for the RequestResponse provided by the requesting party. Maximum 9000 characters.',
    )
    eligible_whitelist_id: Optional[int] = Field(
        None, description='The whitelist id for this action or null.'
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The Geolocation where the RequestResponse was created.'
    )
    id: Optional[int] = Field(None, description='The id of the RequestResponse.')
    minimum_age: Optional[int] = Field(
        None,
        description='The minimum age the user accepting the RequestResponse must have.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the MonetaryAccount the RequestResponse was received on.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to after accepting or rejecting the Request.',
    )
    require_address: Optional[str] = Field(
        None, description='Whether or not an address must be provided on accept.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the created RequestResponse. Can only be PENDING.',
    )
    sub_type: Optional[str] = Field(
        None, description='The subtype of the RequestResponse. Can be only be NONE.'
    )
    time_expiry: Optional[str] = Field(
        None,
        description='The timestamp of when the RequestResponse expired or will expire.',
    )
    time_responded: Optional[str] = Field(
        None, description='The timestamp of when the RequestResponse was responded to.'
    )
    type: Optional[str] = Field(
        None, description='The type of the RequestResponse. Can be only be IDEAL.'
    )


class TransferwiseRequirementFieldGroup(BaseModel):
    display_format: Optional[str] = Field(
        None, description='Formatting mask to guide user input.'
    )
    example: Optional[str] = Field(None, description='An example value for this field.')
    key: Optional[str] = Field(
        None, description='The key of the field. This is the value to send as input.'
    )
    max_length: Optional[str] = Field(
        None, description="The maximum length of the field's value."
    )
    min_length: Optional[str] = Field(
        None, description="The minimum length of the field's value."
    )
    name: Optional[str] = Field(None, description='The field name.')
    refresh_requirements_on_change: Optional[bool] = Field(
        None,
        description='Indicates that any changes in this field affect the requirements, if this field is changed, the requirements endpoint must be called again to recheck if there are any additional requirements.',
    )
    required: Optional[bool] = Field(
        None, description='Whether or not the field is required.'
    )
    type: Optional[str] = Field(
        None, description='The field\'s input type: "text", "select" or "radio".'
    )
    validation_async: Optional[TransferwiseRequirementFieldGroupValidationAsync] = (
        Field(
            None,
            description='Details of an endpoint which may be used to validate the user input.',
        )
    )
    validation_regexp: Optional[str] = Field(
        None,
        description='A regular expression which may be used to validate the user input.',
    )
    values_allowed: Optional[TransferwiseRequirementFieldGroupValuesAllowed] = Field(
        None,
        description='Shows which values are allowed for fields of type "select" or "radio".',
    )


class TransferwiseTransfer(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    amount_source: Optional[Amount] = Field(None, description='The source amount.')
    amount_target: Optional[Amount] = Field(None, description='The target amount.')
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the Payment.',
    )
    monetary_account_id: str = Field(
        ...,
        description='The id of the monetary account the payment should be made from.',
    )
    pay_in_reference: Optional[str] = Field(
        None, description='The Pay-In reference of the payment.'
    )
    quote: Optional[TransferwiseQuote] = Field(
        None, description='The quote details used to created the payment.'
    )
    rate: Optional[str] = Field(None, description='The rate of the payment.')
    recipient_id: str = Field(..., description='The id of the target account.')
    reference: Optional[str] = Field(None, description='The reference of the payment.')
    status: Optional[str] = Field(None, description='The status.')
    status_transferwise: Optional[str] = Field(
        None, description='The status as Transferwise reports it.'
    )
    status_transferwise_issue: Optional[str] = Field(
        None,
        description='A status to indicatie if Transferwise has an issue with this payment and requires more information.',
    )
    sub_status: Optional[str] = Field(None, description='The subStatus.')
    time_delivery_estimate: Optional[str] = Field(
        None, description='The estimated delivery time.'
    )


class TransferwiseTransferListing(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    amount_source: Optional[Amount] = Field(None, description='The source amount.')
    amount_target: Optional[Amount] = Field(None, description='The target amount.')
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the Payment.',
    )
    pay_in_reference: Optional[str] = Field(
        None, description='The Pay-In reference of the payment.'
    )
    quote: Optional[TransferwiseQuote] = Field(
        None, description='The quote details used to created the payment.'
    )
    rate: Optional[str] = Field(None, description='The rate of the payment.')
    reference: Optional[str] = Field(None, description='The reference of the payment.')
    status: Optional[str] = Field(None, description='The status.')
    status_transferwise: Optional[str] = Field(
        None, description='The status as Transferwise reports it.'
    )
    status_transferwise_issue: Optional[str] = Field(
        None,
        description='A status to indicatie if Transferwise has an issue with this payment and requires more information.',
    )
    sub_status: Optional[str] = Field(None, description='The subStatus.')
    time_delivery_estimate: Optional[str] = Field(
        None, description='The estimated delivery time.'
    )


class TransferwiseTransferRead(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    amount_source: Optional[Amount] = Field(None, description='The source amount.')
    amount_target: Optional[Amount] = Field(None, description='The target amount.')
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the Payment.',
    )
    pay_in_reference: Optional[str] = Field(
        None, description='The Pay-In reference of the payment.'
    )
    quote: Optional[TransferwiseQuote] = Field(
        None, description='The quote details used to created the payment.'
    )
    rate: Optional[str] = Field(None, description='The rate of the payment.')
    reference: Optional[str] = Field(None, description='The reference of the payment.')
    status: Optional[str] = Field(None, description='The status.')
    status_transferwise: Optional[str] = Field(
        None, description='The status as Transferwise reports it.'
    )
    status_transferwise_issue: Optional[str] = Field(
        None,
        description='A status to indicatie if Transferwise has an issue with this payment and requires more information.',
    )
    sub_status: Optional[str] = Field(None, description='The subStatus.')
    time_delivery_estimate: Optional[str] = Field(
        None, description='The estimated delivery time.'
    )


class TranslinkTransactionEntry(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the payment.",
    )
    amount: Optional[Amount] = Field(None, description='The amount of the payment.')
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The Attachments attached to the payment.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the payment.',
    )
    description: Optional[str] = Field(
        None,
        description='The description for the payment. Maximum 140 characters for payments to external IBANs, 9000 characters for payments to only other bunq MonetaryAccounts.',
    )
    id: Optional[int] = Field(None, description='The id of the payment entry.')
    merchant_reference: Optional[str] = Field(
        None,
        description='Optional data to be included with the Payment specific to the merchant.',
    )
    type: Optional[str] = Field(None, description='The type of the payment entry.')


class UserApiKeyAnchoredUser(BaseModel):
    UserCompany_1: Optional[UserCompany] = Field(
        None, alias='UserCompany', description=''
    )
    UserPaymentServiceProvider_1: Optional[UserPaymentServiceProvider] = Field(
        None, alias='UserPaymentServiceProvider', description=''
    )
    UserPerson_1: Optional[UserPerson] = Field(None, alias='UserPerson', description='')


class WhitelistSddListing(BaseModel):
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The account to which payments will be paid.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None, description='The credit scheme ID provided by the counterparty.'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    mandate_identifier: Optional[str] = Field(
        None, description='The mandate ID provided by the counterparty.'
    )
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The monthly maximum amount that can be deducted from the target account.',
    )
    monetary_account_incoming_id: Optional[int] = Field(
        None,
        description="The account to which payments will come in before possibly being 'redirected' by the whitelist.",
    )
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    status: Optional[str] = Field(None, description='The status of the whitelist.')
    type: Optional[str] = Field(
        None, description='The type of the SDD whitelist, can be CORE or B2B.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the whitelist entry.'
    )


class WhitelistSddMonetaryAccountPayingListing(BaseModel):
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The account to which payments will be paid.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None, description='The credit scheme ID provided by the counterparty.'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    mandate_identifier: Optional[str] = Field(
        None, description='The mandate ID provided by the counterparty.'
    )
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The monthly maximum amount that can be deducted from the target account.',
    )
    monetary_account_incoming_id: Optional[int] = Field(
        None,
        description="The account to which payments will come in before possibly being 'redirected' by the whitelist.",
    )
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    status: Optional[str] = Field(None, description='The status of the whitelist.')
    type: Optional[str] = Field(
        None, description='The type of the SDD whitelist, can be CORE or B2B.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the whitelist entry.'
    )


class WhitelistSddMonetaryAccountPayingRead(BaseModel):
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The account to which payments will be paid.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None, description='The credit scheme ID provided by the counterparty.'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    mandate_identifier: Optional[str] = Field(
        None, description='The mandate ID provided by the counterparty.'
    )
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The monthly maximum amount that can be deducted from the target account.',
    )
    monetary_account_incoming_id: Optional[int] = Field(
        None,
        description="The account to which payments will come in before possibly being 'redirected' by the whitelist.",
    )
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    status: Optional[str] = Field(None, description='The status of the whitelist.')
    type: Optional[str] = Field(
        None, description='The type of the SDD whitelist, can be CORE or B2B.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the whitelist entry.'
    )


class WhitelistSddOneOffListing(BaseModel):
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The account to which payments will be paid.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None, description='The credit scheme ID provided by the counterparty.'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The monthly maximum amount that can be deducted from the target account.',
    )
    monetary_account_incoming_id: Optional[int] = Field(
        None,
        description="The account to which payments will come in before possibly being 'redirected' by the whitelist.",
    )
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    status: Optional[str] = Field(None, description='The status of the whitelist.')
    type: Optional[str] = Field(
        None, description='The type of the SDD whitelist, can be CORE or B2B.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the whitelist entry.'
    )


class WhitelistSddOneOffRead(BaseModel):
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The account to which payments will be paid.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None, description='The credit scheme ID provided by the counterparty.'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The monthly maximum amount that can be deducted from the target account.',
    )
    monetary_account_incoming_id: Optional[int] = Field(
        None,
        description="The account to which payments will come in before possibly being 'redirected' by the whitelist.",
    )
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    status: Optional[str] = Field(None, description='The status of the whitelist.')
    type: Optional[str] = Field(
        None, description='The type of the SDD whitelist, can be CORE or B2B.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the whitelist entry.'
    )


class WhitelistSddRead(BaseModel):
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The account to which payments will be paid.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None, description='The credit scheme ID provided by the counterparty.'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    mandate_identifier: Optional[str] = Field(
        None, description='The mandate ID provided by the counterparty.'
    )
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The monthly maximum amount that can be deducted from the target account.',
    )
    monetary_account_incoming_id: Optional[int] = Field(
        None,
        description="The account to which payments will come in before possibly being 'redirected' by the whitelist.",
    )
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    status: Optional[str] = Field(None, description='The status of the whitelist.')
    type: Optional[str] = Field(
        None, description='The type of the SDD whitelist, can be CORE or B2B.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the whitelist entry.'
    )


class WhitelistSddRecurringListing(BaseModel):
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The account to which payments will be paid.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None, description='The credit scheme ID provided by the counterparty.'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    mandate_identifier: Optional[str] = Field(
        None, description='The mandate ID provided by the counterparty.'
    )
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The monthly maximum amount that can be deducted from the target account.',
    )
    monetary_account_incoming_id: Optional[int] = Field(
        None,
        description="The account to which payments will come in before possibly being 'redirected' by the whitelist.",
    )
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    status: Optional[str] = Field(None, description='The status of the whitelist.')
    type: Optional[str] = Field(
        None, description='The type of the SDD whitelist, can be CORE or B2B.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the whitelist entry.'
    )


class WhitelistSddRecurringRead(BaseModel):
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The account to which payments will be paid.'
    )
    credit_scheme_identifier: Optional[str] = Field(
        None, description='The credit scheme ID provided by the counterparty.'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    mandate_identifier: Optional[str] = Field(
        None, description='The mandate ID provided by the counterparty.'
    )
    maximum_amount_per_month: Optional[Amount] = Field(
        None,
        description='The monthly maximum amount that can be deducted from the target account.',
    )
    monetary_account_incoming_id: Optional[int] = Field(
        None,
        description="The account to which payments will come in before possibly being 'redirected' by the whitelist.",
    )
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    status: Optional[str] = Field(None, description='The status of the whitelist.')
    type: Optional[str] = Field(
        None, description='The type of the SDD whitelist, can be CORE or B2B.'
    )
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The user who created the whitelist entry.'
    )


class UserUserIDCompanyGetResponse(RootModel[List[CompanyListing]]):
    root: List[CompanyListing]


class UserUserIDExportAnnualOverviewGetResponse(
    RootModel[List[ExportAnnualOverviewListing]]
):
    root: List[ExportAnnualOverviewListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestResponseGetResponse(
    RootModel[List[RequestResponseListing]]
):
    root: List[RequestResponseListing]


class UserUserIDMonetaryAccountMonetaryAccountIDShareInviteMonetaryAccountInquiryGetResponse(
    RootModel[List[ShareInviteMonetaryAccountInquiryListing]]
):
    root: List[ShareInviteMonetaryAccountInquiryListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSofortMerchantTransactionGetResponse(
    RootModel[List[SofortMerchantTransactionListing]]
):
    root: List[SofortMerchantTransactionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDWhitelistSddGetResponse(
    RootModel[List[WhitelistSddMonetaryAccountPayingListing]]
):
    root: List[WhitelistSddMonetaryAccountPayingListing]


class UserUserIDPaymentAutoAllocateGetResponse(
    RootModel[List[PaymentAutoAllocateUserListing]]
):
    root: List[PaymentAutoAllocateUserListing]


class UserUserIDRegistryRegistryIDRegistrySettlementGetResponse(
    RootModel[List[RegistrySettlementListing]]
):
    root: List[RegistrySettlementListing]


class UserUserIDShareInviteMonetaryAccountResponseGetResponse(
    RootModel[List[ShareInviteMonetaryAccountResponseListing]]
):
    root: List[ShareInviteMonetaryAccountResponseListing]


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseTransferGetResponse(
    RootModel[List[TransferwiseTransferListing]]
):
    root: List[TransferwiseTransferListing]


class UserUserIDWhitelistSddGetResponse(RootModel[List[WhitelistSddListing]]):
    root: List[WhitelistSddListing]


class UserUserIDWhitelistSddOneOffGetResponse(
    RootModel[List[WhitelistSddOneOffListing]]
):
    root: List[WhitelistSddOneOffListing]


class UserUserIDWhitelistSddRecurringGetResponse(
    RootModel[List[WhitelistSddRecurringListing]]
):
    root: List[WhitelistSddRecurringListing]


class BankSwitchServiceNetherlandsIncoming(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the monetary of this switch service.'
    )
    attachment: Optional[Attachment] = Field(
        None, description='Reference to the bank transfer form for this switch-service.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description="The IBAN alias that's displayed for this switch service."
    )
    status: Optional[str] = Field(None, description='The status of the switch service.')
    sub_status: Optional[str] = Field(
        None, description='The sub status of the switch service.'
    )
    time_end: Optional[str] = Field(
        None, description='The timestamp when the switch service ends.'
    )
    time_start_actual: Optional[str] = Field(
        None, description='The timestamp when the switch service actually starts.'
    )
    time_start_desired: Optional[str] = Field(
        None, description='The timestamp when the switch service desired to be start.'
    )
    user_alias: Optional[LabelUser] = Field(
        None, description='The label of the user creator of this switch service.'
    )


class BunqMeFundraiserProfile(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the User and the MonetaryAccount that created the bunq.me fundraiser profile.',
    )
    attachment: Optional[AttachmentPublic] = Field(
        None, description='The attachment attached to the fundraiser profile.'
    )
    color: Optional[str] = Field(
        None,
        description='The color chosen for the bunq.me fundraiser profile in hexadecimal format.',
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccount that created the bunq.me fundraiser profile.',
    )
    description: Optional[str] = Field(
        None, description='The description of the bunq.me fundraiser profile.'
    )
    invite_profile_name: Optional[str] = Field(
        None, description='Provided if the user has enabled their invite link.'
    )
    pointer: Optional[Pointer] = Field(
        None,
        description='The pointer (url) which will be used to access the bunq.me fundraiser profile.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to when a payment is completed.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the bunq.me fundraiser profile, can be ACTIVE or DEACTIVATED.',
    )


class BunqMeFundraiserProfileUserListing(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the User and the MonetaryAccount that created the bunq.me fundraiser profile.',
    )
    attachment: Optional[AttachmentPublic] = Field(
        None,
        description='The attachment used for the background of the bunq.me fundraiser profile.',
    )
    color: Optional[str] = Field(
        None,
        description='The color chosen for the bunq.me fundraiser profile in hexadecimal format.',
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccount that created the bunq.me fundraiser profile.',
    )
    description: Optional[str] = Field(
        None, description='The description of the bunq.me fundraiser profile.'
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='Id of the monetary account on which you want to receive bunq.me payments.',
    )
    owner_user_id: Optional[int] = Field(
        None, description='Id of the user owning the profile.'
    )
    pointer: Optional[Pointer] = Field(
        None,
        description='The pointer (url) which will be used to access the bunq.me fundraiser profile.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to when a payment is completed.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the bunq.me fundraiser profile, can be ACTIVE or DEACTIVATED.',
    )


class BunqMeFundraiserProfileUserRead(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the User and the MonetaryAccount that created the bunq.me fundraiser profile.',
    )
    attachment: Optional[AttachmentPublic] = Field(
        None,
        description='The attachment used for the background of the bunq.me fundraiser profile.',
    )
    color: Optional[str] = Field(
        None,
        description='The color chosen for the bunq.me fundraiser profile in hexadecimal format.',
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccount that created the bunq.me fundraiser profile.',
    )
    description: Optional[str] = Field(
        None, description='The description of the bunq.me fundraiser profile.'
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='Id of the monetary account on which you want to receive bunq.me payments.',
    )
    owner_user_id: Optional[int] = Field(
        None, description='Id of the user owning the profile.'
    )
    pointer: Optional[Pointer] = Field(
        None,
        description='The pointer (url) which will be used to access the bunq.me fundraiser profile.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to when a payment is completed.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the bunq.me fundraiser profile, can be ACTIVE or DEACTIVATED.',
    )


class BunqMeTabEntry(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the User and the MonetaryAccount that created the bunq.me link.',
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested Amount.')
    description: Optional[str] = Field(
        None, description='The description for the bunq.me. Maximum 9000 characters.'
    )
    invite_profile_name: Optional[str] = Field(
        None, description='Provided if the user has enabled their invite link.'
    )
    merchant_available: Optional[List[BunqMeMerchantAvailable]] = Field(
        None, description='List of available merchants.'
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to when a payment is completed.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the bunq.me. Can be WAITING_FOR_PAYMENT, CANCELLED or EXPIRED.',
    )
    uuid: Optional[str] = Field(None, description='The uuid of the bunq.me.')


class CardListing(BaseModel):
    card_limit: Optional[Amount] = Field(
        None, description='The spending limit for the card.'
    )
    card_limit_atm: Optional[Amount] = Field(
        None, description='The ATM spending limit for the card.'
    )
    card_shipment_tracking_url: Optional[str] = Field(
        None, description='A tracking link provided by our shipment provider.'
    )
    country: Optional[str] = Field(
        None,
        description='The country that is domestic to the card. Defaults to country of residence of user.',
    )
    country_permission: Optional[List[CardCountryPermission]] = Field(
        None,
        description='The countries for which to grant (temporary) permissions to use the card.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the card's creation."
    )
    expiry_date: Optional[str] = Field(None, description='Expiry date of the card.')
    id: Optional[int] = Field(None, description='The id of the card.')
    label_monetary_account_current: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The monetary account that this card is currently linked to and the label user viewing it.',
    )
    label_monetary_account_ordered: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The monetary account this card was ordered on and the label user that owns the card.',
    )
    monetary_account_id_fallback: Optional[int] = Field(
        None,
        description='ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.',
    )
    name_on_card: Optional[str] = Field(
        None, description="The user's name on the card."
    )
    order_status: Optional[str] = Field(
        None,
        description='The order status of the card. Can be NEW_CARD_REQUEST_RECEIVED, CARD_REQUEST_PENDING, SENT_FOR_PRODUCTION, ACCEPTED_FOR_PRODUCTION, DELIVERED_TO_CUSTOMER, CARD_UPDATE_REQUESTED, CARD_UPDATE_PENDING, CARD_UPDATE_SENT, CARD_UPDATE_ACCEPTED, VIRTUAL_DELIVERY, NEW_CARD_REQUEST_PENDING_USER_APPROVAL, SENT_FOR_DELIVERY or NEW_CARD_REQUEST_CANCELLED.',
    )
    payment_account_reference: Optional[str] = Field(
        None,
        description='The payment account reference number associated with the card.',
    )
    pin_code_assignment: Optional[List[CardPinAssignment]] = Field(
        None, description='Array of Types, PINs, account IDs assigned to the card.'
    )
    primary_account_numbers: Optional[List[CardPrimaryAccountNumber]] = Field(
        None, description='Array of PANs and their attributes.'
    )
    public_uuid: Optional[str] = Field(None, description='The public UUID of the card.')
    second_line: Optional[str] = Field(
        None, description='The second line of text on the card'
    )
    status: Optional[str] = Field(
        None,
        description='The status to set for the card. Can be ACTIVE, DEACTIVATED, LOST, STOLEN, CANCELLED, EXPIRED or PIN_TRIES_EXCEEDED.',
    )
    sub_status: Optional[str] = Field(
        None, description='The sub-status of the card. Can be NONE or REPLACED.'
    )
    sub_type: Optional[str] = Field(None, description='The sub-type of the card.')
    type: Optional[str] = Field(
        None, description='The type of the card. Can be MAESTRO, MASTERCARD.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the card's last update."
    )
    user_id: Optional[int] = Field(
        None, description='ID of the user who is owner of the card.'
    )


class CardRead(BaseModel):
    card_limit: Optional[Amount] = Field(
        None, description='The spending limit for the card.'
    )
    card_limit_atm: Optional[Amount] = Field(
        None, description='The ATM spending limit for the card.'
    )
    card_shipment_tracking_url: Optional[str] = Field(
        None, description='A tracking link provided by our shipment provider.'
    )
    country: Optional[str] = Field(
        None,
        description='The country that is domestic to the card. Defaults to country of residence of user.',
    )
    country_permission: Optional[List[CardCountryPermission]] = Field(
        None,
        description='The countries for which to grant (temporary) permissions to use the card.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the card's creation."
    )
    expiry_date: Optional[str] = Field(None, description='Expiry date of the card.')
    id: Optional[int] = Field(None, description='The id of the card.')
    label_monetary_account_current: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The monetary account that this card is currently linked to and the label user viewing it.',
    )
    label_monetary_account_ordered: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The monetary account this card was ordered on and the label user that owns the card.',
    )
    monetary_account_id_fallback: Optional[int] = Field(
        None,
        description='ID of the MA to be used as fallback for this card if insufficient balance. Fallback account is removed if not supplied.',
    )
    name_on_card: Optional[str] = Field(
        None, description="The user's name on the card."
    )
    order_status: Optional[str] = Field(
        None,
        description='The order status of the card. Can be NEW_CARD_REQUEST_RECEIVED, CARD_REQUEST_PENDING, SENT_FOR_PRODUCTION, ACCEPTED_FOR_PRODUCTION, DELIVERED_TO_CUSTOMER, CARD_UPDATE_REQUESTED, CARD_UPDATE_PENDING, CARD_UPDATE_SENT, CARD_UPDATE_ACCEPTED, VIRTUAL_DELIVERY, NEW_CARD_REQUEST_PENDING_USER_APPROVAL, SENT_FOR_DELIVERY or NEW_CARD_REQUEST_CANCELLED.',
    )
    payment_account_reference: Optional[str] = Field(
        None,
        description='The payment account reference number associated with the card.',
    )
    pin_code_assignment: Optional[List[CardPinAssignment]] = Field(
        None, description='Array of Types, PINs, account IDs assigned to the card.'
    )
    primary_account_numbers: Optional[List[CardPrimaryAccountNumber]] = Field(
        None, description='Array of PANs and their attributes.'
    )
    public_uuid: Optional[str] = Field(None, description='The public UUID of the card.')
    second_line: Optional[str] = Field(
        None, description='The second line of text on the card'
    )
    status: Optional[str] = Field(
        None,
        description='The status to set for the card. Can be ACTIVE, DEACTIVATED, LOST, STOLEN, CANCELLED, EXPIRED or PIN_TRIES_EXCEEDED.',
    )
    sub_status: Optional[str] = Field(
        None, description='The sub-status of the card. Can be NONE or REPLACED.'
    )
    sub_type: Optional[str] = Field(None, description='The sub-type of the card.')
    type: Optional[str] = Field(
        None, description='The type of the card. Can be MAESTRO, MASTERCARD.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the card's last update."
    )
    user_id: Optional[int] = Field(
        None, description='ID of the user who is owner of the card.'
    )


class DraftPaymentEntry(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the DraftPayment.",
    )
    amount: Optional[Amount] = Field(None, description='The amount of the payment.')
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The Attachments attached to the DraftPayment.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the DraftPayment.',
    )
    description: Optional[str] = Field(
        None,
        description='The description for the DraftPayment. Maximum 140 characters for DraftPayments to external IBANs, 9000 characters for DraftPayments to only other bunq MonetaryAccounts.',
    )
    id: Optional[int] = Field(None, description='The id of the draft payment entry.')
    merchant_reference: Optional[str] = Field(
        None,
        description='Optional data to be included with the Payment specific to the merchant.',
    )
    type: Optional[str] = Field(
        None, description='The type of the draft payment entry.'
    )


class ExportStatementListing(BaseModel):
    alias_monetary_account: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account for which this statement was created.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    date_end: Optional[str] = Field(
        None, description='The date until which statement shows transactions.'
    )
    date_start: Optional[str] = Field(
        None, description='The date from when this statement shows transactions.'
    )
    id: Optional[int] = Field(
        None, description='The id of the customer statement model.'
    )
    regional_format: Optional[str] = Field(
        None, description='The regional format of a CSV statement.'
    )
    statement_format: Optional[str] = Field(
        None, description='The format of statement.'
    )
    statement_number: Optional[int] = Field(
        None, description='MT940 Statement number. Unique per monetary account.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class ExportStatementRead(BaseModel):
    alias_monetary_account: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account for which this statement was created.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the statement model's creation."
    )
    date_end: Optional[str] = Field(
        None, description='The date until which statement shows transactions.'
    )
    date_start: Optional[str] = Field(
        None, description='The date from when this statement shows transactions.'
    )
    id: Optional[int] = Field(
        None, description='The id of the customer statement model.'
    )
    regional_format: Optional[str] = Field(
        None, description='The regional format of a CSV statement.'
    )
    statement_format: Optional[str] = Field(
        None, description='The format of statement.'
    )
    statement_number: Optional[int] = Field(
        None, description='MT940 Statement number. Unique per monetary account.'
    )
    status: Optional[str] = Field(None, description='The status of the export.')
    updated: Optional[str] = Field(
        None, description="The timestamp of the statement model's last update."
    )


class IdealMerchantTransaction(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account to add money to.'
    )
    amount_guaranteed: Optional[Amount] = Field(
        None,
        description='In case of a successful transaction, the amount of money that will be transferred.',
    )
    amount_requested: Optional[Amount] = Field(
        None, description='The requested amount of money to add.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account the money comes from.'
    )
    expiration: Optional[str] = Field(
        None, description='When the transaction will expire.'
    )
    issuer: Optional[str] = Field(None, description='The BIC of the issuer.')
    issuer_authentication_url: Optional[str] = Field(
        None, description='The URL to visit to '
    )
    issuer_name: Optional[str] = Field(None, description='The Name of the issuer.')
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account this ideal merchant transaction links to.',
    )
    purchase_identifier: Optional[str] = Field(
        None, description="The 'purchase ID' of the iDEAL transaction."
    )
    status: Optional[str] = Field(None, description='The status of the transaction.')
    status_timestamp: Optional[str] = Field(
        None, description='When the status was last updated.'
    )
    transaction_identifier: Optional[str] = Field(
        None, description="The 'transaction ID' of the iDEAL transaction."
    )


class IdealMerchantTransactionListing(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account to add money to.'
    )
    amount_guaranteed: Optional[Amount] = Field(
        None,
        description='In case of a successful transaction, the amount of money that will be transferred.',
    )
    amount_requested: Optional[Amount] = Field(
        None, description='The requested amount of money to add.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account the money comes from.'
    )
    expiration: Optional[str] = Field(
        None, description='When the transaction will expire.'
    )
    issuer: Optional[str] = Field(None, description='The BIC of the issuer.')
    issuer_authentication_url: Optional[str] = Field(
        None, description='The URL to visit to '
    )
    issuer_name: Optional[str] = Field(None, description='The Name of the issuer.')
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account this ideal merchant transaction links to.',
    )
    purchase_identifier: Optional[str] = Field(
        None, description="The 'purchase ID' of the iDEAL transaction."
    )
    status: Optional[str] = Field(None, description='The status of the transaction.')
    status_timestamp: Optional[str] = Field(
        None, description='When the status was last updated.'
    )
    transaction_identifier: Optional[str] = Field(
        None, description="The 'transaction ID' of the iDEAL transaction."
    )


class IdealMerchantTransactionRead(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account to add money to.'
    )
    amount_guaranteed: Optional[Amount] = Field(
        None,
        description='In case of a successful transaction, the amount of money that will be transferred.',
    )
    amount_requested: Optional[Amount] = Field(
        None, description='The requested amount of money to add.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The alias of the monetary account the money comes from.'
    )
    expiration: Optional[str] = Field(
        None, description='When the transaction will expire.'
    )
    issuer: Optional[str] = Field(None, description='The BIC of the issuer.')
    issuer_authentication_url: Optional[str] = Field(
        None, description='The URL to visit to '
    )
    issuer_name: Optional[str] = Field(None, description='The Name of the issuer.')
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account this ideal merchant transaction links to.',
    )
    purchase_identifier: Optional[str] = Field(
        None, description="The 'purchase ID' of the iDEAL transaction."
    )
    status: Optional[str] = Field(None, description='The status of the transaction.')
    status_timestamp: Optional[str] = Field(
        None, description='When the status was last updated.'
    )
    transaction_identifier: Optional[str] = Field(
        None, description="The 'transaction ID' of the iDEAL transaction."
    )


class Invoice(BaseModel):
    address: Optional[Address] = Field(None, description="The customer's address.")
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The label that's displayed to the counterparty with the invoice. Includes user.",
    )
    category: Optional[str] = Field(
        None, description='The category to display to the user.'
    )
    chamber_of_commerce_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )
    counterparty_address: Optional[Address] = Field(
        None, description="The company's address."
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the counterparty of the invoice. Includes user.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the invoice object's creation."
    )
    description: str = Field(..., description='The description provided by the admin.')
    external_url: str = Field(
        ..., description='The external url provided by the admin.'
    )
    group: Optional[List[InvoiceItemGroup]] = Field(
        None, description='The invoice item groups.'
    )
    id: Optional[int] = Field(None, description='The id of the invoice object.')
    invoice_date: Optional[str] = Field(None, description='The invoice date.')
    invoice_number: Optional[str] = Field(None, description='The invoice number.')
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    status: Optional[str] = Field(None, description='The invoice status.')
    total_vat: Optional[Amount] = Field(
        None, description='The VAT on the total discounted item price.'
    )
    total_vat_exclusive: Optional[Amount] = Field(
        None, description='The total discounted item price excluding VAT.'
    )
    total_vat_inclusive: Optional[Amount] = Field(
        None, description='The total discounted item price including VAT.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the invoice object's last update."
    )
    vat_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )


class InvoiceByUserListing(BaseModel):
    address: Optional[Address] = Field(None, description="The customer's address.")
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The label that's displayed to the counterparty with the invoice. Includes user.",
    )
    chamber_of_commerce_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )
    counterparty_address: Optional[Address] = Field(
        None, description="The company's address."
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the counterparty of the invoice. Includes user.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the invoice object's creation."
    )
    group: Optional[List[InvoiceItemGroup]] = Field(
        None, description='The invoice item groups.'
    )
    id: Optional[int] = Field(None, description='The id of the invoice object.')
    invoice_date: Optional[str] = Field(None, description='The invoice date.')
    invoice_number: Optional[str] = Field(None, description='The invoice number.')
    status: Optional[str] = Field(None, description='The invoice status.')
    total_vat: Optional[Amount] = Field(
        None, description='The VAT on the total discounted item price.'
    )
    total_vat_exclusive: Optional[Amount] = Field(
        None, description='The total discounted item price excluding VAT.'
    )
    total_vat_inclusive: Optional[Amount] = Field(
        None, description='The total discounted item price including VAT.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the invoice object's last update."
    )
    vat_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )


class InvoiceByUserRead(BaseModel):
    address: Optional[Address] = Field(None, description="The customer's address.")
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The label that's displayed to the counterparty with the invoice. Includes user.",
    )
    chamber_of_commerce_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )
    counterparty_address: Optional[Address] = Field(
        None, description="The company's address."
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the counterparty of the invoice. Includes user.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the invoice object's creation."
    )
    group: Optional[List[InvoiceItemGroup]] = Field(
        None, description='The invoice item groups.'
    )
    id: Optional[int] = Field(None, description='The id of the invoice object.')
    invoice_date: Optional[str] = Field(None, description='The invoice date.')
    invoice_number: Optional[str] = Field(None, description='The invoice number.')
    status: Optional[str] = Field(None, description='The invoice status.')
    total_vat: Optional[Amount] = Field(
        None, description='The VAT on the total discounted item price.'
    )
    total_vat_exclusive: Optional[Amount] = Field(
        None, description='The total discounted item price excluding VAT.'
    )
    total_vat_inclusive: Optional[Amount] = Field(
        None, description='The total discounted item price including VAT.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the invoice object's last update."
    )
    vat_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )


class InvoiceListing(BaseModel):
    address: Optional[Address] = Field(None, description="The customer's address.")
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The label that's displayed to the counterparty with the invoice. Includes user.",
    )
    category: Optional[str] = Field(
        None, description='The category to display to the user.'
    )
    chamber_of_commerce_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )
    counterparty_address: Optional[Address] = Field(
        None, description="The company's address."
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the counterparty of the invoice. Includes user.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the invoice object's creation."
    )
    group: Optional[List[InvoiceItemGroup]] = Field(
        None, description='The invoice item groups.'
    )
    id: Optional[int] = Field(None, description='The id of the invoice object.')
    invoice_date: Optional[str] = Field(None, description='The invoice date.')
    invoice_number: Optional[str] = Field(None, description='The invoice number.')
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    status: Optional[str] = Field(None, description='The invoice status.')
    total_vat: Optional[Amount] = Field(
        None, description='The VAT on the total discounted item price.'
    )
    total_vat_exclusive: Optional[Amount] = Field(
        None, description='The total discounted item price excluding VAT.'
    )
    total_vat_inclusive: Optional[Amount] = Field(
        None, description='The total discounted item price including VAT.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the invoice object's last update."
    )
    vat_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )


class InvoiceRead(BaseModel):
    address: Optional[Address] = Field(None, description="The customer's address.")
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The label that's displayed to the counterparty with the invoice. Includes user.",
    )
    category: Optional[str] = Field(
        None, description='The category to display to the user.'
    )
    chamber_of_commerce_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )
    counterparty_address: Optional[Address] = Field(
        None, description="The company's address."
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the counterparty of the invoice. Includes user.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the invoice object's creation."
    )
    group: Optional[List[InvoiceItemGroup]] = Field(
        None, description='The invoice item groups.'
    )
    id: Optional[int] = Field(None, description='The id of the invoice object.')
    invoice_date: Optional[str] = Field(None, description='The invoice date.')
    invoice_number: Optional[str] = Field(None, description='The invoice number.')
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    status: Optional[str] = Field(None, description='The invoice status.')
    total_vat: Optional[Amount] = Field(
        None, description='The VAT on the total discounted item price.'
    )
    total_vat_exclusive: Optional[Amount] = Field(
        None, description='The total discounted item price excluding VAT.'
    )
    total_vat_inclusive: Optional[Amount] = Field(
        None, description='The total discounted item price including VAT.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the invoice object's last update."
    )
    vat_number: Optional[str] = Field(
        None, description="The company's chamber of commerce number."
    )


class MasterCardAction(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The monetary account label of the account that this action is created for.',
    )
    all_mastercard_action_refund: Optional[List[MasterCardActionRefund]] = Field(
        None, description='A reference to the Refunds if they exist.'
    )
    amount_billing: Optional[Amount] = Field(
        None,
        description="The amount of the transaction in the monetary account's currency.",
    )
    amount_converted: Optional[Amount] = Field(
        None, description='The amount of the transaction in local currency.'
    )
    amount_fee: Optional[Amount] = Field(
        None, description='The fee amount as charged by the merchant, if applicable.'
    )
    amount_local: Optional[Amount] = Field(
        None, description='The amount of the transaction in local currency.'
    )
    amount_original_billing: Optional[Amount] = Field(
        None, description="The original amount in the monetary account's currency."
    )
    amount_original_local: Optional[Amount] = Field(
        None, description='The original amount in local currency.'
    )
    applied_limit: Optional[str] = Field(
        None,
        description='The type of the limit applied to validate if this MasterCardAction was within the spending limits. The returned string matches the limit types as defined in the card endpoint.',
    )
    authorisation_status: Optional[str] = Field(
        None, description='The status in the authorisation process.'
    )
    authorisation_type: Optional[str] = Field(
        None, description='The type of transaction that was delivered using the card.'
    )
    card_authorisation_id_response: Optional[str] = Field(
        None,
        description='The response code by which authorised transaction can be identified as authorised by bunq.',
    )
    card_id: Optional[int] = Field(
        None, description='The id of the card this action links to.'
    )
    city: Optional[str] = Field(
        None,
        description='The city where the message originates from as announced by the terminal.',
    )
    clearing_expiry_time: Optional[str] = Field(
        None,
        description='The time when the processing of the clearing is expired, refunding the authorisation.',
    )
    clearing_status: Optional[str] = Field(
        None,
        description="The clearing status of the authorisation. Can be 'PENDING', 'FIRST_PRESENTMENT_COMPLETE' or 'REFUND_LENIENCY'.",
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account label of the counterparty.'
    )
    decision: Optional[str] = Field(
        None,
        description='Why the transaction was denied, if it was denied, or just ALLOWED.',
    )
    decision_description: Optional[str] = Field(
        None,
        description='Empty if allowed, otherwise a textual explanation of why it was denied.',
    )
    decision_description_translated: Optional[str] = Field(
        None,
        description="Empty if allowed, otherwise a textual explanation of why it was denied in user's language.",
    )
    decision_together_url: Optional[str] = Field(
        None,
        description='Empty if allowed or if no relevant Together topic exists, otherwise contains the URL for a Together topic with more information about the decision.',
    )
    description: Optional[str] = Field(
        None, description='The description for this transaction to display.'
    )
    eligible_whitelist_id: Optional[int] = Field(
        None, description='The whitelist id for this action or null.'
    )
    id: Optional[int] = Field(None, description='The id of the MastercardAction.')
    label_card: Optional[LabelCard] = Field(None, description='The label of the card.')
    maturity_date: Optional[str] = Field(None, description='The maturity date.')
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the monetary account this action links to.'
    )
    pan_entry_mode_user: Optional[str] = Field(
        None,
        description="The type of entry mode the user used. Can be 'ATM', 'ICC', 'MAGNETIC_STRIPE' or 'E_COMMERCE'.",
    )
    payment_status: Optional[str] = Field(
        None,
        description='The payment status of the transaction. For example PAYMENT_SUCCESSFUL, for a successful payment.',
    )
    pos_card_holder_presence: Optional[str] = Field(
        None, description='The Card Holder Presence type of the POS.'
    )
    pos_card_presence: Optional[str] = Field(
        None, description='The Card Presence type of the POS.'
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    reservation_expiry_time: Optional[str] = Field(
        None,
        description='If this is a reservation, the moment the reservation will expire.',
    )
    secure_code_id: Optional[int] = Field(
        None, description='The secure code id for this mastercard action or null.'
    )
    settlement_status: Optional[str] = Field(
        None, description='The setlement status in the authorisation process.'
    )
    token_status: Optional[str] = Field(
        None,
        description='If this is a tokenisation action, this shows the status of the token.',
    )
    wallet_provider_id: Optional[str] = Field(
        None,
        description='The ID of the wallet provider as defined by MasterCard. 420 = bunq Android app with Tap&Pay; 103 = Apple Pay.',
    )


class MasterCardActionListing(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The monetary account label of the account that this action is created for.',
    )
    all_mastercard_action_refund: Optional[List[MasterCardActionRefund]] = Field(
        None, description='A reference to the Refunds if they exist.'
    )
    amount_billing: Optional[Amount] = Field(
        None,
        description="The amount of the transaction in the monetary account's currency.",
    )
    amount_converted: Optional[Amount] = Field(
        None, description='The amount of the transaction in local currency.'
    )
    amount_fee: Optional[Amount] = Field(
        None, description='The fee amount as charged by the merchant, if applicable.'
    )
    amount_local: Optional[Amount] = Field(
        None, description='The amount of the transaction in local currency.'
    )
    amount_original_billing: Optional[Amount] = Field(
        None, description="The original amount in the monetary account's currency."
    )
    amount_original_local: Optional[Amount] = Field(
        None, description='The original amount in local currency.'
    )
    applied_limit: Optional[str] = Field(
        None,
        description='The type of the limit applied to validate if this MasterCardAction was within the spending limits. The returned string matches the limit types as defined in the card endpoint.',
    )
    authorisation_status: Optional[str] = Field(
        None, description='The status in the authorisation process.'
    )
    authorisation_type: Optional[str] = Field(
        None, description='The type of transaction that was delivered using the card.'
    )
    card_authorisation_id_response: Optional[str] = Field(
        None,
        description='The response code by which authorised transaction can be identified as authorised by bunq.',
    )
    card_id: Optional[int] = Field(
        None, description='The id of the card this action links to.'
    )
    city: Optional[str] = Field(
        None,
        description='The city where the message originates from as announced by the terminal.',
    )
    clearing_expiry_time: Optional[str] = Field(
        None,
        description='The time when the processing of the clearing is expired, refunding the authorisation.',
    )
    clearing_status: Optional[str] = Field(
        None,
        description="The clearing status of the authorisation. Can be 'PENDING', 'FIRST_PRESENTMENT_COMPLETE' or 'REFUND_LENIENCY'.",
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account label of the counterparty.'
    )
    decision: Optional[str] = Field(
        None,
        description='Why the transaction was denied, if it was denied, or just ALLOWED.',
    )
    decision_description: Optional[str] = Field(
        None,
        description='Empty if allowed, otherwise a textual explanation of why it was denied.',
    )
    decision_description_translated: Optional[str] = Field(
        None,
        description="Empty if allowed, otherwise a textual explanation of why it was denied in user's language.",
    )
    decision_together_url: Optional[str] = Field(
        None,
        description='Empty if allowed or if no relevant Together topic exists, otherwise contains the URL for a Together topic with more information about the decision.',
    )
    description: Optional[str] = Field(
        None, description='The description for this transaction to display.'
    )
    eligible_whitelist_id: Optional[int] = Field(
        None, description='The whitelist id for this action or null.'
    )
    id: Optional[int] = Field(None, description='The id of the MastercardAction.')
    label_card: Optional[LabelCard] = Field(None, description='The label of the card.')
    maturity_date: Optional[str] = Field(None, description='The maturity date.')
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the monetary account this action links to.'
    )
    pan_entry_mode_user: Optional[str] = Field(
        None,
        description="The type of entry mode the user used. Can be 'ATM', 'ICC', 'MAGNETIC_STRIPE' or 'E_COMMERCE'.",
    )
    payment_status: Optional[str] = Field(
        None,
        description='The payment status of the transaction. For example PAYMENT_SUCCESSFUL, for a successful payment.',
    )
    pos_card_holder_presence: Optional[str] = Field(
        None, description='The Card Holder Presence type of the POS.'
    )
    pos_card_presence: Optional[str] = Field(
        None, description='The Card Presence type of the POS.'
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    reservation_expiry_time: Optional[str] = Field(
        None,
        description='If this is a reservation, the moment the reservation will expire.',
    )
    secure_code_id: Optional[int] = Field(
        None, description='The secure code id for this mastercard action or null.'
    )
    settlement_status: Optional[str] = Field(
        None, description='The setlement status in the authorisation process.'
    )
    token_status: Optional[str] = Field(
        None,
        description='If this is a tokenisation action, this shows the status of the token.',
    )
    wallet_provider_id: Optional[str] = Field(
        None,
        description='The ID of the wallet provider as defined by MasterCard. 420 = bunq Android app with Tap&Pay; 103 = Apple Pay.',
    )


class MasterCardActionRead(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The monetary account label of the account that this action is created for.',
    )
    all_mastercard_action_refund: Optional[List[MasterCardActionRefund]] = Field(
        None, description='A reference to the Refunds if they exist.'
    )
    amount_billing: Optional[Amount] = Field(
        None,
        description="The amount of the transaction in the monetary account's currency.",
    )
    amount_converted: Optional[Amount] = Field(
        None, description='The amount of the transaction in local currency.'
    )
    amount_fee: Optional[Amount] = Field(
        None, description='The fee amount as charged by the merchant, if applicable.'
    )
    amount_local: Optional[Amount] = Field(
        None, description='The amount of the transaction in local currency.'
    )
    amount_original_billing: Optional[Amount] = Field(
        None, description="The original amount in the monetary account's currency."
    )
    amount_original_local: Optional[Amount] = Field(
        None, description='The original amount in local currency.'
    )
    applied_limit: Optional[str] = Field(
        None,
        description='The type of the limit applied to validate if this MasterCardAction was within the spending limits. The returned string matches the limit types as defined in the card endpoint.',
    )
    authorisation_status: Optional[str] = Field(
        None, description='The status in the authorisation process.'
    )
    authorisation_type: Optional[str] = Field(
        None, description='The type of transaction that was delivered using the card.'
    )
    card_authorisation_id_response: Optional[str] = Field(
        None,
        description='The response code by which authorised transaction can be identified as authorised by bunq.',
    )
    card_id: Optional[int] = Field(
        None, description='The id of the card this action links to.'
    )
    city: Optional[str] = Field(
        None,
        description='The city where the message originates from as announced by the terminal.',
    )
    clearing_expiry_time: Optional[str] = Field(
        None,
        description='The time when the processing of the clearing is expired, refunding the authorisation.',
    )
    clearing_status: Optional[str] = Field(
        None,
        description="The clearing status of the authorisation. Can be 'PENDING', 'FIRST_PRESENTMENT_COMPLETE' or 'REFUND_LENIENCY'.",
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None, description='The monetary account label of the counterparty.'
    )
    decision: Optional[str] = Field(
        None,
        description='Why the transaction was denied, if it was denied, or just ALLOWED.',
    )
    decision_description: Optional[str] = Field(
        None,
        description='Empty if allowed, otherwise a textual explanation of why it was denied.',
    )
    decision_description_translated: Optional[str] = Field(
        None,
        description="Empty if allowed, otherwise a textual explanation of why it was denied in user's language.",
    )
    decision_together_url: Optional[str] = Field(
        None,
        description='Empty if allowed or if no relevant Together topic exists, otherwise contains the URL for a Together topic with more information about the decision.',
    )
    description: Optional[str] = Field(
        None, description='The description for this transaction to display.'
    )
    eligible_whitelist_id: Optional[int] = Field(
        None, description='The whitelist id for this action or null.'
    )
    id: Optional[int] = Field(None, description='The id of the MastercardAction.')
    label_card: Optional[LabelCard] = Field(None, description='The label of the card.')
    maturity_date: Optional[str] = Field(None, description='The maturity date.')
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the monetary account this action links to.'
    )
    pan_entry_mode_user: Optional[str] = Field(
        None,
        description="The type of entry mode the user used. Can be 'ATM', 'ICC', 'MAGNETIC_STRIPE' or 'E_COMMERCE'.",
    )
    payment_status: Optional[str] = Field(
        None,
        description='The payment status of the transaction. For example PAYMENT_SUCCESSFUL, for a successful payment.',
    )
    pos_card_holder_presence: Optional[str] = Field(
        None, description='The Card Holder Presence type of the POS.'
    )
    pos_card_presence: Optional[str] = Field(
        None, description='The Card Presence type of the POS.'
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    reservation_expiry_time: Optional[str] = Field(
        None,
        description='If this is a reservation, the moment the reservation will expire.',
    )
    secure_code_id: Optional[int] = Field(
        None, description='The secure code id for this mastercard action or null.'
    )
    settlement_status: Optional[str] = Field(
        None, description='The setlement status in the authorisation process.'
    )
    token_status: Optional[str] = Field(
        None,
        description='If this is a tokenisation action, this shows the status of the token.',
    )
    wallet_provider_id: Optional[str] = Field(
        None,
        description='The ID of the wallet provider as defined by MasterCard. 420 = bunq Android app with Tap&Pay; 103 = Apple Pay.',
    )


class MonetaryAccountProfile(BaseModel):
    profile_drain: Optional[MonetaryAccountProfileDrain] = Field(
        None,
        description='The profile settings for moving excesses to a savings account',
    )
    profile_fill: Optional[MonetaryAccountProfileFill] = Field(
        None,
        description='The profile settings for triggering the fill of a monetary account.',
    )


class MonetaryAccountSavingsListing(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountSavings.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    all_co_owner: Optional[List[CoOwner]] = Field(
        None, description='The users the account will be joint with.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountSavings.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountSavings.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountSavings's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountSavings as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountSavings. Defaults to 1000 EUR. Currency must match the MonetaryAccountSavings's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountSavings. Defaults to 'bunq account'.",
    )
    id: Optional[int] = Field(None, description='The id of the MonetaryAccountSavings.')
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountSavings can be 'in the red'. Must be 0 EUR or omitted.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountSavings's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountSavings, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountSavings. Can be any user provided message.',
    )
    savings_goal: Optional[Amount] = Field(
        None, description='The Savings Goal set for this MonetaryAccountSavings.'
    )
    savings_goal_progress: Optional[int] = Field(
        None,
        description='The progress in percentages for the Savings Goal set for this MonetaryAccountSavings.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountSavings.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountSavings. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountSavings providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountSavings's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountSavings.'
    )


class MonetaryAccountSavingsRead(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountSavings.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    all_co_owner: Optional[List[CoOwner]] = Field(
        None, description='The users the account will be joint with.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountSavings.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountSavings.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountSavings's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountSavings as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountSavings. Defaults to 1000 EUR. Currency must match the MonetaryAccountSavings's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountSavings. Defaults to 'bunq account'.",
    )
    id: Optional[int] = Field(None, description='The id of the MonetaryAccountSavings.')
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountSavings can be 'in the red'. Must be 0 EUR or omitted.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountSavings's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountSavings, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountSavings. Can be any user provided message.',
    )
    savings_goal: Optional[Amount] = Field(
        None, description='The Savings Goal set for this MonetaryAccountSavings.'
    )
    savings_goal_progress: Optional[int] = Field(
        None,
        description='The progress in percentages for the Savings Goal set for this MonetaryAccountSavings.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountSavings.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountSavings. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountSavings providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountSavings's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountSavings.'
    )


class TransferwiseRequirementField(BaseModel):
    group: Optional[TransferwiseRequirementFieldGroup] = Field(
        None, description='The field group.'
    )
    key: str = Field(..., description='The name of the required field.')
    name: Optional[str] = Field(None, description='The descriptive label of the field.')
    value: str = Field(..., description='The value of the required field.')


class TransferwiseTransferRequirement(BaseModel):
    detail: Optional[List[TransferwiseRequirementField]] = Field(
        None,
        description='The fields which were specified as "required" and have since been filled by the user. Always provide the full list.',
    )
    recipient_id: str = Field(..., description='The id of the target account.')


class UserApiKey(BaseModel):
    created: Optional[str] = Field(
        None, description="The timestamp of the user object's creation."
    )
    granted_by_user: Optional[UserApiKeyAnchoredUser] = Field(
        None, description='The user who granted access.'
    )
    id: Optional[int] = Field(None, description='The id of the user.')
    requested_by_user: Optional[UserApiKeyAnchoredUser] = Field(
        None, description='The user who requested access.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the user object's last update."
    )


class UserListing(BaseModel):
    UserApiKey_1: Optional[UserApiKey] = Field(None, alias='UserApiKey', description='')
    UserCompany_1: Optional[UserCompany] = Field(
        None, alias='UserCompany', description=''
    )
    UserPaymentServiceProvider_1: Optional[UserPaymentServiceProvider] = Field(
        None, alias='UserPaymentServiceProvider', description=''
    )
    UserPerson_1: Optional[UserPerson] = Field(None, alias='UserPerson', description='')


class UserRead(BaseModel):
    UserApiKey_1: Optional[UserApiKey] = Field(None, alias='UserApiKey', description='')
    UserCompany_1: Optional[UserCompany] = Field(
        None, alias='UserCompany', description=''
    )
    UserPaymentServiceProvider_1: Optional[UserPaymentServiceProvider] = Field(
        None, alias='UserPaymentServiceProvider', description=''
    )
    UserPerson_1: Optional[UserPerson] = Field(None, alias='UserPerson', description='')


class UserGetResponse(RootModel[List[UserListing]]):
    root: List[UserListing]


class UserUserIDBunqmeFundraiserProfileGetResponse(
    RootModel[List[BunqMeFundraiserProfileUserListing]]
):
    root: List[BunqMeFundraiserProfileUserListing]


class UserUserIDCardGetResponse(RootModel[List[CardListing]]):
    root: List[CardListing]


class UserUserIDInvoiceGetResponse(RootModel[List[InvoiceByUserListing]]):
    root: List[InvoiceByUserListing]


class UserUserIDMonetaryAccountSavingsGetResponse(
    RootModel[List[MonetaryAccountSavingsListing]]
):
    root: List[MonetaryAccountSavingsListing]


class UserUserIDMonetaryAccountMonetaryAccountIDCustomerStatementGetResponse(
    RootModel[List[ExportStatementListing]]
):
    root: List[ExportStatementListing]


class UserUserIDMonetaryAccountMonetaryAccountIDIdealMerchantTransactionGetResponse(
    RootModel[List[IdealMerchantTransactionListing]]
):
    root: List[IdealMerchantTransactionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDInvoiceGetResponse(
    RootModel[List[InvoiceListing]]
):
    root: List[InvoiceListing]


class UserUserIDMonetaryAccountMonetaryAccountIDMastercardActionGetResponse(
    RootModel[List[MasterCardActionListing]]
):
    root: List[MasterCardActionListing]


class BunqMeTab(BaseModel):
    bunqme_tab_entry: BunqMeTabEntry = Field(
        ..., description='The bunq.me entry containing the payment information.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the bunq.me. Ignored in POST requests but can be used for cancelling the bunq.me by setting status as CANCELLED with a PUT request.',
    )


class MonetaryAccountBankListing(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountBank.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountBank.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountBank.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountBank's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountBank as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountBank. Defaults to 1000 EUR. Currency must match the MonetaryAccountBank's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountBank. Defaults to 'bunq account'.",
    )
    display_name: Optional[str] = Field(
        None,
        description='The legal name of the user / company using this monetary account.',
    )
    id: Optional[int] = Field(None, description='The id of the MonetaryAccountBank.')
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountBank can be 'in the red'.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountBank's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountBank, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountBank. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountBank.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountBank. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountBank providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountBank's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountBank.'
    )


class MonetaryAccountBankRead(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountBank.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountBank.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountBank.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountBank's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountBank as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountBank. Defaults to 1000 EUR. Currency must match the MonetaryAccountBank's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountBank. Defaults to 'bunq account'.",
    )
    display_name: Optional[str] = Field(
        None,
        description='The legal name of the user / company using this monetary account.',
    )
    id: Optional[int] = Field(None, description='The id of the MonetaryAccountBank.')
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountBank can be 'in the red'.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountBank's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountBank, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountBank. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountBank.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountBank. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountBank providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountBank's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountBank.'
    )


class MonetaryAccountExternal(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountExternal.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountExternal.'
    )
    avatar_uuid: Optional[str] = Field(
        None, description='The UUID of the Avatar of the MonetaryAccountExternal.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountExternal.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountExternal's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountExternal as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountExternal. Defaults to 1000 EUR. Currency must match the MonetaryAccountExternal's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountExternal. Defaults to 'bunq account'.",
    )
    display_name: Optional[str] = Field(
        None,
        description='The legal name of the user / company using this monetary account.',
    )
    id: Optional[int] = Field(
        None, description='The id of the MonetaryAccountExternal.'
    )
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountExternal can be 'in the red'.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountExternal's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountExternal, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternal. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountExternal.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountExternal. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountExternal providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountExternal's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountExternal.'
    )


class MonetaryAccountExternalListing(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountExternal.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountExternal.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountExternal.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountExternal's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountExternal as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountExternal. Defaults to 1000 EUR. Currency must match the MonetaryAccountExternal's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountExternal. Defaults to 'bunq account'.",
    )
    display_name: Optional[str] = Field(
        None,
        description='The legal name of the user / company using this monetary account.',
    )
    id: Optional[int] = Field(
        None, description='The id of the MonetaryAccountExternal.'
    )
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountExternal can be 'in the red'.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountExternal's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountExternal, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternal. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountExternal.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountExternal. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountExternal providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountExternal's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountExternal.'
    )


class MonetaryAccountExternalRead(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountExternal.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountExternal.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountExternal.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountExternal's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountExternal as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountExternal. Defaults to 1000 EUR. Currency must match the MonetaryAccountExternal's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountExternal. Defaults to 'bunq account'.",
    )
    display_name: Optional[str] = Field(
        None,
        description='The legal name of the user / company using this monetary account.',
    )
    id: Optional[int] = Field(
        None, description='The id of the MonetaryAccountExternal.'
    )
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountExternal can be 'in the red'.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountExternal's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountExternal, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountExternal. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountExternal.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountExternal. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountExternal providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountExternal's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountExternal.'
    )


class MonetaryAccountInvestment(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountInvestment.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountInvestment.'
    )
    avatar_uuid: Optional[str] = Field(
        None, description='The UUID of the Avatar of the MonetaryAccountInvestment.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountInvestment.',
    )
    birdee_investment_portfolio: Optional[BirdeeInvestmentPortfolio] = Field(
        None, description='The Birdee investment portfolio.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountInvestment's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountInvestment as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountInvestment. Defaults to 1000 EUR. Currency must match the MonetaryAccountInvestment's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountInvestment. Defaults to 'bunq account'.",
    )
    display_name: Optional[str] = Field(
        None,
        description='The legal name of the user / company using this monetary account.',
    )
    id: Optional[int] = Field(
        None, description='The id of the MonetaryAccountInvestment.'
    )
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    provider: str = Field(..., description='The provider of the investment service.')
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountInvestment's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountInvestment, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountInvestment. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountInvestment.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountInvestment. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountInvestment providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None,
        description="The timestamp of the MonetaryAccountInvestment's last update.",
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountInvestment.'
    )


class MonetaryAccountJointListing(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountJoint.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    all_co_owner: Optional[List[CoOwner]] = Field(
        None, description='The users the account will be joint with.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountJoint.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountJoint.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountJoint's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountJoint as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountJoint. Defaults to 1000 EUR. Currency must match the MonetaryAccountJoint's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountJoint. Defaults to 'bunq account'.",
    )
    id: Optional[int] = Field(None, description='The id of the MonetaryAccountJoint.')
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountJoint can be 'in the red'.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountJoint's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountJoint, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountJoint. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountJoint.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountJoint. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountJoint providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountJoint's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountJoint.'
    )


class MonetaryAccountJointRead(BaseModel):
    alias: Optional[List[Pointer]] = Field(
        None, description='The Aliases for the MonetaryAccountJoint.'
    )
    all_auto_save_id: Optional[List[BunqId]] = Field(
        None, description='The ids of the AutoSave.'
    )
    all_co_owner: Optional[List[CoOwner]] = Field(
        None, description='The users the account will be joint with.'
    )
    avatar: Optional[Avatar] = Field(
        None, description='The Avatar of the MonetaryAccountJoint.'
    )
    balance: Optional[Amount] = Field(
        None,
        description='The current available balance Amount of the MonetaryAccountJoint.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountJoint's creation."
    )
    currency: Optional[str] = Field(
        None,
        description='The currency of the MonetaryAccountJoint as an ISO 4217 formatted currency code.',
    )
    daily_limit: Optional[Amount] = Field(
        None,
        description="The daily spending limit Amount of the MonetaryAccountJoint. Defaults to 1000 EUR. Currency must match the MonetaryAccountJoint's currency. Limited to 10000 EUR.",
    )
    description: Optional[str] = Field(
        None,
        description="The description of the MonetaryAccountJoint. Defaults to 'bunq account'.",
    )
    id: Optional[int] = Field(None, description='The id of the MonetaryAccountJoint.')
    monetary_account_profile: Optional[MonetaryAccountProfile] = Field(
        None, description='The profile of the account.'
    )
    overdraft_limit: Optional[Amount] = Field(
        None,
        description="The maximum Amount the MonetaryAccountJoint can be 'in the red'.",
    )
    public_uuid: Optional[str] = Field(
        None, description="The MonetaryAccountJoint's public UUID."
    )
    reason: Optional[str] = Field(
        None,
        description='The reason for voluntarily cancelling (closing) the MonetaryAccountJoint, can only be OTHER.',
    )
    reason_description: Optional[str] = Field(
        None,
        description='The optional free-form reason for voluntarily cancelling (closing) the MonetaryAccountJoint. Can be any user provided message.',
    )
    setting: Optional[MonetaryAccountSetting] = Field(
        None, description='The settings of the MonetaryAccountJoint.'
    )
    status: Optional[str] = Field(
        None,
        description='The status of the MonetaryAccountJoint. Can be: ACTIVE, BLOCKED, CANCELLED or PENDING_REOPEN',
    )
    sub_status: Optional[str] = Field(
        None,
        description='The sub-status of the MonetaryAccountJoint providing extra information regarding the status. Will be NONE for ACTIVE or PENDING_REOPEN, COMPLETELY or ONLY_ACCEPTING_INCOMING for BLOCKED and REDEMPTION_INVOLUNTARY, REDEMPTION_VOLUNTARY or PERMANENT for CANCELLED.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the MonetaryAccountJoint's last update."
    )
    user_id: Optional[int] = Field(
        None, description='The id of the User who owns the MonetaryAccountJoint.'
    )


class MonetaryAccountListing(BaseModel):
    MonetaryAccountBank_1: Optional[MonetaryAccountBank] = Field(
        None, alias='MonetaryAccountBank', description=''
    )
    MonetaryAccountExternal_1: Optional[MonetaryAccountExternal] = Field(
        None, alias='MonetaryAccountExternal', description=''
    )
    MonetaryAccountInvestment_1: Optional[MonetaryAccountInvestment] = Field(
        None, alias='MonetaryAccountInvestment', description=''
    )
    MonetaryAccountJoint_1: Optional[MonetaryAccountJoint] = Field(
        None, alias='MonetaryAccountJoint', description=''
    )
    MonetaryAccountLight_1: Optional[MonetaryAccountLight] = Field(
        None, alias='MonetaryAccountLight', description=''
    )
    MonetaryAccountSavings_1: Optional[MonetaryAccountSavings] = Field(
        None, alias='MonetaryAccountSavings', description=''
    )


class MonetaryAccountRead(BaseModel):
    MonetaryAccountBank_1: Optional[MonetaryAccountBank] = Field(
        None, alias='MonetaryAccountBank', description=''
    )
    MonetaryAccountExternal_1: Optional[MonetaryAccountExternal] = Field(
        None, alias='MonetaryAccountExternal', description=''
    )
    MonetaryAccountInvestment_1: Optional[MonetaryAccountInvestment] = Field(
        None, alias='MonetaryAccountInvestment', description=''
    )
    MonetaryAccountJoint_1: Optional[MonetaryAccountJoint] = Field(
        None, alias='MonetaryAccountJoint', description=''
    )
    MonetaryAccountLight_1: Optional[MonetaryAccountLight] = Field(
        None, alias='MonetaryAccountLight', description=''
    )
    MonetaryAccountSavings_1: Optional[MonetaryAccountSavings] = Field(
        None, alias='MonetaryAccountSavings', description=''
    )


class SessionServerCreate(BaseModel):
    Id: Optional[BunqId] = Field(
        None, description='The Id object of the created Session.'
    )
    Token: Optional[SessionServerToken] = Field(
        None, description='The token object of this Session.'
    )
    UserApiKey_1: Optional[UserApiKey] = Field(
        None,
        alias='UserApiKey',
        description='The UserApiKey object that is logged in with this Session.',
    )
    UserCompany_1: Optional[UserCompany] = Field(
        None,
        alias='UserCompany',
        description='The UserCompany object that is logged in with this Session.',
    )
    UserPaymentServiceProvider_1: Optional[UserPaymentServiceProvider] = Field(
        None,
        alias='UserPaymentServiceProvider',
        description='The UserPaymentServiceProvider object that is logged in with this Session.',
    )
    UserPerson_1: Optional[UserPerson] = Field(
        None,
        alias='UserPerson',
        description='The UserPerson object that is logged in with this Session.',
    )


class TransferwiseAccountQuote(BaseModel):
    country: Optional[str] = Field(
        None, description='The country of the receiving account.'
    )
    detail: Optional[List[TransferwiseRequirementField]] = Field(
        None,
        description='The fields which were specified as "required" and have since been filled by the user. Always provide the full list.',
    )
    name_account_holder: str = Field(..., description='The name of the account holder.')
    type: str = Field(
        ...,
        description='The chosen recipient account type. The possible options are provided dynamically in the response endpoint.',
    )


class TransferwiseAccountRequirement(BaseModel):
    country: Optional[str] = Field(
        None, description='The country of the receiving account.'
    )
    detail: Optional[List[TransferwiseRequirementField]] = Field(
        None,
        description='The fields which were specified as "required" and have since been filled by the user. Always provide the full list.',
    )
    name_account_holder: str = Field(..., description='The name of the account holder.')
    type: str = Field(
        ...,
        description='The chosen recipient account type. The possible options are provided dynamically in the response endpoint.',
    )


class TransferwiseAccountRequirementListing(BaseModel):
    fields: Optional[List[TransferwiseRequirementField]] = Field(
        None, description='The fields which the user needs to fill.'
    )
    label: Optional[str] = Field(
        None,
        description='The label of the possible recipient account type to show to the user.',
    )
    type: Optional[str] = Field(None, description='A possible recipient account type.')


class UserUserIDMonetaryAccountGetResponse(RootModel[List[MonetaryAccountListing]]):
    root: List[MonetaryAccountListing]


class UserUserIDMonetaryAccountBankGetResponse(
    RootModel[List[MonetaryAccountBankListing]]
):
    root: List[MonetaryAccountBankListing]


class UserUserIDMonetaryAccountExternalGetResponse(
    RootModel[List[MonetaryAccountExternalListing]]
):
    root: List[MonetaryAccountExternalListing]


class UserUserIDMonetaryAccountJointGetResponse(
    RootModel[List[MonetaryAccountJointListing]]
):
    root: List[MonetaryAccountJointListing]


class UserUserIDTransferwiseQuoteTransferwiseQuoteIDTransferwiseRecipientRequirementGetResponse(
    RootModel[List[TransferwiseAccountRequirementListing]]
):
    root: List[TransferwiseAccountRequirementListing]


class BankSwitchServiceNetherlandsIncomingPayment(BaseModel):
    bank_switch_service: Optional[BankSwitchServiceNetherlandsIncoming] = Field(
        None, description='The bank switch service details.'
    )
    payment: Optional[Payment] = Field(
        None, description='The payment made using bank switch service.'
    )


class BankSwitchServiceNetherlandsIncomingPaymentRead(BaseModel):
    bank_switch_service: Optional[BankSwitchServiceNetherlandsIncoming] = Field(
        None, description='The bank switch service details.'
    )
    payment: Optional[Payment] = Field(
        None, description='The payment made using bank switch service.'
    )


class BunqMeFundraiserResult(BaseModel):
    bunqme_fundraiser_profile: Optional[BunqMeFundraiserProfile] = Field(
        None, description='The bunq.me fundraiser profile.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the bunq.me was created.'
    )
    id: Optional[int] = Field(None, description='The id of the bunq.me.')
    payments: Optional[List[Payment]] = Field(
        None,
        description='The list of payments, paid to the bunq.me fundraiser profile.',
    )
    updated: Optional[str] = Field(
        None, description='The timestamp when the bunq.me was last updated.'
    )


class BunqMeFundraiserResultRead(BaseModel):
    bunqme_fundraiser_profile: Optional[BunqMeFundraiserProfile] = Field(
        None, description='The bunq.me fundraiser profile.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the bunq.me was created.'
    )
    id: Optional[int] = Field(None, description='The id of the bunq.me.')
    payments: Optional[List[Payment]] = Field(
        None,
        description='The list of payments, paid to the bunq.me fundraiser profile.',
    )
    updated: Optional[str] = Field(
        None, description='The timestamp when the bunq.me was last updated.'
    )


class BunqMeTabListing(BaseModel):
    alias_monetary_account: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the User and the MonetaryAccount that created the bunq.me link.',
    )
    bunqme_tab_entries: Optional[List[BunqMeTabEntry]] = Field(
        None, description='The bunq.me tab entries attached to this bunq.me Tab.'
    )
    bunqme_tab_entry: Optional[BunqMeTabEntry] = Field(
        None, description='The bunq.me entry containing the payment information.'
    )
    bunqme_tab_share_url: Optional[str] = Field(
        None, description='The url that points to the bunq.me page.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the bunq.me was created.'
    )
    id: Optional[int] = Field(None, description='The id of the created bunq.me.')
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the MonetaryAccount the bunq.me was sent from.'
    )
    result_inquiries: Optional[List[BunqMeTabResultInquiry]] = Field(
        None,
        description='The list of bunq.me result Inquiries successfully made and paid.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the bunq.me. Can be WAITING_FOR_PAYMENT, CANCELLED or EXPIRED.',
    )
    time_expiry: Optional[str] = Field(
        None, description='The timestamp of when the bunq.me expired or will expire.'
    )
    type: Optional[str] = Field(
        None, description='The type of the bunq.me Tab. Should be BUNQ_ME'
    )
    updated: Optional[str] = Field(
        None, description='The timestamp when the bunq.me was last updated.'
    )


class BunqMeTabRead(BaseModel):
    alias_monetary_account: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the User and the MonetaryAccount that created the bunq.me link.',
    )
    bunqme_tab_entries: Optional[List[BunqMeTabEntry]] = Field(
        None, description='The bunq.me tab entries attached to this bunq.me Tab.'
    )
    bunqme_tab_entry: Optional[BunqMeTabEntry] = Field(
        None, description='The bunq.me entry containing the payment information.'
    )
    bunqme_tab_share_url: Optional[str] = Field(
        None, description='The url that points to the bunq.me page.'
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the bunq.me was created.'
    )
    id: Optional[int] = Field(None, description='The id of the created bunq.me.')
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the MonetaryAccount the bunq.me was sent from.'
    )
    result_inquiries: Optional[List[BunqMeTabResultInquiry]] = Field(
        None,
        description='The list of bunq.me result Inquiries successfully made and paid.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the bunq.me. Can be WAITING_FOR_PAYMENT, CANCELLED or EXPIRED.',
    )
    time_expiry: Optional[str] = Field(
        None, description='The timestamp of when the bunq.me expired or will expire.'
    )
    type: Optional[str] = Field(
        None, description='The type of the bunq.me Tab. Should be BUNQ_ME'
    )
    updated: Optional[str] = Field(
        None, description='The timestamp when the bunq.me was last updated.'
    )


class BunqMeTabResultInquiry(BaseModel):
    bunq_me_tab_id: Optional[int] = Field(
        None,
        description='The Id of the bunq.me tab that this BunqMeTabResultInquiry belongs to.',
    )
    payment: Optional[Payment] = Field(
        None, description='The payment made for the Tab.'
    )


class BunqMeTabResultResponse(BaseModel):
    payment: Optional[Payment] = Field(
        None, description='The payment made for the bunq.me tab.'
    )


class BunqMeTabResultResponseRead(BaseModel):
    payment: Optional[Payment] = Field(
        None, description='The payment made for the bunq.me tab.'
    )


class CurrencyConversionListing(BaseModel):
    amount: Optional[Amount] = Field(None, description='The amount of the conversion.')
    counter_amount: Optional[Amount] = Field(
        None, description='The amount of the counter conversion.'
    )
    counter_label_monetary_account: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the counter monetary account.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the conversion's creation."
    )
    date_delivery_expected: Optional[str] = Field(
        None, description='The expected delivery date of the conversion.'
    )
    group_uuid: Optional[str] = Field(
        None, description='The group uuid of the conversion.'
    )
    id: Optional[int] = Field(None, description='The id of the conversion.')
    label_monetary_account: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the monetary account.'
    )
    payment: Optional[Payment] = Field(
        None, description='The payment associated with this conversion.'
    )
    rate: Optional[str] = Field(None, description='The rate of the conversion.')
    status: Optional[str] = Field(None, description='The status of the conversion.')
    type: Optional[str] = Field(
        None, description='The type of this conversion in the pair.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the conversion's last update."
    )


class CurrencyConversionRead(BaseModel):
    amount: Optional[Amount] = Field(None, description='The amount of the conversion.')
    counter_amount: Optional[Amount] = Field(
        None, description='The amount of the counter conversion.'
    )
    counter_label_monetary_account: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the counter monetary account.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the conversion's creation."
    )
    date_delivery_expected: Optional[str] = Field(
        None, description='The expected delivery date of the conversion.'
    )
    group_uuid: Optional[str] = Field(
        None, description='The group uuid of the conversion.'
    )
    id: Optional[int] = Field(None, description='The id of the conversion.')
    label_monetary_account: Optional[LabelMonetaryAccount] = Field(
        None, description='The label of the monetary account.'
    )
    payment: Optional[Payment] = Field(
        None, description='The payment associated with this conversion.'
    )
    rate: Optional[str] = Field(None, description='The rate of the conversion.')
    status: Optional[str] = Field(None, description='The status of the conversion.')
    type: Optional[str] = Field(
        None, description='The type of this conversion in the pair.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the conversion's last update."
    )


class DraftPayment(BaseModel):
    entries: List[DraftPaymentEntry] = Field(
        ...,
        description='The list of entries in the DraftPayment. Each entry will result in a payment when the DraftPayment is accepted.',
    )
    number_of_required_accepts: int = Field(
        ...,
        description='The number of accepts that are required for the draft payment to receive status ACCEPTED. Currently only 1 is valid.',
    )
    previous_updated_timestamp: Optional[str] = Field(
        None,
        description='The last updated_timestamp that you received for this DraftPayment. This needs to be provided to prevent race conditions.',
    )
    schedule: Optional[Schedule] = Field(
        None,
        description='The schedule details when creating or updating a scheduled payment.',
    )
    status: Optional[str] = Field(None, description='The status of the DraftPayment.')


class DraftPaymentAnchorObject(BaseModel):
    Payment_1: Optional[Payment] = Field(None, alias='Payment', description='')
    PaymentBatch_1: Optional[PaymentBatch] = Field(
        None, alias='PaymentBatch', description=''
    )


class DraftPaymentListing(BaseModel):
    entries: Optional[List[DraftPaymentEntry]] = Field(
        None, description='The entries in the DraftPayment.'
    )
    id: Optional[int] = Field(None, description='The id of the created DrafPayment.')
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the MonetaryAccount the DraftPayment applies to.'
    )
    object: Optional[DraftPaymentAnchorObject] = Field(
        None,
        description='The Payment or PaymentBatch. This will only be present after the DraftPayment has been accepted.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    responses: Optional[List[DraftPaymentResponse]] = Field(
        None, description='All responses to this draft payment.'
    )
    schedule: Optional[Schedule] = Field(None, description='The schedule details.')
    status: Optional[str] = Field(None, description='The status of the DraftPayment.')
    type: Optional[str] = Field(None, description='The type of the DraftPayment.')
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The label of the User who created the DraftPayment.'
    )


class DraftPaymentRead(BaseModel):
    entries: Optional[List[DraftPaymentEntry]] = Field(
        None, description='The entries in the DraftPayment.'
    )
    id: Optional[int] = Field(None, description='The id of the created DrafPayment.')
    monetary_account_id: Optional[int] = Field(
        None, description='The id of the MonetaryAccount the DraftPayment applies to.'
    )
    object: Optional[DraftPaymentAnchorObject] = Field(
        None,
        description='The Payment or PaymentBatch. This will only be present after the DraftPayment has been accepted.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    responses: Optional[List[DraftPaymentResponse]] = Field(
        None, description='All responses to this draft payment.'
    )
    schedule: Optional[Schedule] = Field(None, description='The schedule details.')
    status: Optional[str] = Field(None, description='The status of the DraftPayment.')
    type: Optional[str] = Field(None, description='The type of the DraftPayment.')
    user_alias_created: Optional[LabelUser] = Field(
        None, description='The label of the User who created the DraftPayment.'
    )


class EventListing(BaseModel):
    action: Optional[str] = Field(
        None, description='The performed action. Can be: CREATE or UPDATE.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the event's creation."
    )
    id: Optional[int] = Field(None, description='The id of the event.')
    monetary_account_id: Optional[str] = Field(
        None,
        description='The id of the monetary account the event applied to (if it was a monetary account event).',
    )
    object: Optional[EventObject] = Field(
        None,
        description='The details of the external object the event was created for.',
    )
    status: Optional[str] = Field(
        None,
        description='The event status. Can be: FINALIZED or AWAITING_REPLY. An example of FINALIZED event is a payment received event, while an AWAITING_REPLY event is a request received event.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the event's last update."
    )
    user_id: Optional[str] = Field(
        None,
        description='The id of the user the event applied to (if it was a user event).',
    )


class EventObject(BaseModel):
    BankSwitchServiceNetherlandsIncomingPayment_1: Optional[
        BankSwitchServiceNetherlandsIncomingPayment
    ] = Field(None, alias='BankSwitchServiceNetherlandsIncomingPayment', description='')
    BunqMeFundraiserResult_1: Optional[BunqMeFundraiserResult] = Field(
        None, alias='BunqMeFundraiserResult', description=''
    )
    BunqMeTab_1: Optional[BunqMeTab] = Field(None, alias='BunqMeTab', description='')
    BunqMeTabResultResponse_1: Optional[BunqMeTabResultResponse] = Field(
        None, alias='BunqMeTabResultResponse', description=''
    )
    Card_1: Optional[Card] = Field(None, alias='Card', description='')
    CardDebit_1: Optional[CardDebit] = Field(None, alias='CardDebit', description='')
    DraftPayment_1: Optional[DraftPayment] = Field(
        None, alias='DraftPayment', description=''
    )
    FeatureAnnouncement_1: Optional[FeatureAnnouncement] = Field(
        None, alias='FeatureAnnouncement', description=''
    )
    IdealMerchantTransaction_1: Optional[IdealMerchantTransaction] = Field(
        None, alias='IdealMerchantTransaction', description=''
    )
    Invoice_1: Optional[Invoice] = Field(None, alias='Invoice', description='')
    MasterCardAction_1: Optional[MasterCardAction] = Field(
        None, alias='MasterCardAction', description=''
    )
    Payment_1: Optional[Payment] = Field(None, alias='Payment', description='')
    PaymentBatch_1: Optional[PaymentBatch] = Field(
        None, alias='PaymentBatch', description=''
    )
    RequestInquiry_1: Optional[RequestInquiry] = Field(
        None, alias='RequestInquiry', description=''
    )
    RequestInquiryBatch_1: Optional[RequestInquiryBatch] = Field(
        None, alias='RequestInquiryBatch', description=''
    )
    RequestResponse_1: Optional[RequestResponse] = Field(
        None, alias='RequestResponse', description=''
    )
    RewardRecipient_1: Optional[RewardRecipient] = Field(
        None, alias='RewardRecipient', description=''
    )
    RewardSender_1: Optional[RewardSender] = Field(
        None, alias='RewardSender', description=''
    )
    ScheduledInstance: Optional[ScheduleInstance] = Field(None, description='')
    ScheduledPayment: Optional[SchedulePayment] = Field(None, description='')
    ScheduledPaymentBatch: Optional[SchedulePaymentBatch] = Field(None, description='')
    ShareInviteBankInquiry: Optional[ShareInviteMonetaryAccountInquiry] = Field(
        None, description=''
    )
    ShareInviteBankResponse: Optional[ShareInviteMonetaryAccountResponse] = Field(
        None, description=''
    )
    SofortMerchantTransaction_1: Optional[SofortMerchantTransaction] = Field(
        None, alias='SofortMerchantTransaction', description=''
    )
    TransferwisePayment: Optional[TransferwiseTransfer] = Field(None, description='')


class EventRead(BaseModel):
    action: Optional[str] = Field(
        None, description='The performed action. Can be: CREATE or UPDATE.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the event's creation."
    )
    id: Optional[int] = Field(None, description='The id of the event.')
    monetary_account_id: Optional[str] = Field(
        None,
        description='The id of the monetary account the event applied to (if it was a monetary account event).',
    )
    object: Optional[EventObject] = Field(
        None,
        description='The details of the external object the event was created for.',
    )
    status: Optional[str] = Field(
        None,
        description='The event status. Can be: FINALIZED or AWAITING_REPLY. An example of FINALIZED event is a payment received event, while an AWAITING_REPLY event is a request received event.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the event's last update."
    )
    user_id: Optional[str] = Field(
        None,
        description='The id of the user the event applied to (if it was a user event).',
    )


class InsightEventListing(BaseModel):
    action: Optional[str] = Field(
        None, description='The performed action. Can be: CREATE or UPDATE.'
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the event's creation."
    )
    id: Optional[int] = Field(None, description='The id of the event.')
    monetary_account_id: Optional[str] = Field(
        None,
        description='The id of the monetary account the event applied to (if it was a monetary account event).',
    )
    object: Optional[EventObject] = Field(
        None,
        description='The details of the external object the event was created for.',
    )
    status: Optional[str] = Field(
        None,
        description='The event status. Can be: FINALIZED or AWAITING_REPLY. An example of FINALIZED event is a payment received event, while an AWAITING_REPLY event is a request received event.',
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the event's last update."
    )
    user_id: Optional[str] = Field(
        None,
        description='The id of the user the event applied to (if it was a user event).',
    )


class Payment(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='A billing Address provided with the Payment, currently unused.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='A shipping Address provided with the Payment, currently unused.',
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    allow_bunqto: Optional[bool] = Field(
        None, description='Whether or not sending a bunq.to payment is allowed.'
    )
    amount: Optional[Amount] = Field(
        None,
        description='The Amount transferred by the Payment. Will be negative for outgoing Payments and positive for incoming Payments (relative to the MonetaryAccount indicated by monetary_account_id).',
    )
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The Attachments attached to the Payment.'
    )
    balance_after_mutation: Optional[Amount] = Field(
        None, description='The new balance of the monetary account after the mutation.'
    )
    batch_id: Optional[int] = Field(
        None, description='The id of the PaymentBatch if this Payment was part of one.'
    )
    bunqto_expiry: Optional[str] = Field(
        None, description='When bunq.to payment is about to expire.'
    )
    bunqto_share_url: Optional[str] = Field(
        None, description='The status of the bunq.to payment.'
    )
    bunqto_status: Optional[str] = Field(
        None, description='The status of the bunq.to payment.'
    )
    bunqto_sub_status: Optional[str] = Field(
        None, description='The sub status of the bunq.to payment.'
    )
    bunqto_time_responded: Optional[str] = Field(
        None, description='The timestamp of when the bunq.to payment was responded to.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the Payment.',
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the Payment was done.'
    )
    description: Optional[str] = Field(
        None,
        description='The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.',
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The Geolocation where the Payment was done from.'
    )
    id: Optional[int] = Field(None, description='The id of the created Payment.')
    merchant_reference: Optional[str] = Field(
        None,
        description='Optional data included with the Payment specific to the merchant.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the MonetaryAccount the Payment was made to or from (depending on whether this is an incoming or outgoing Payment).',
    )
    payment_auto_allocate_instance: Optional[PaymentAutoAllocateInstance] = Field(
        None, description='A reference to the PaymentAutoAllocateInstance if it exists.'
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    scheduled_id: Optional[int] = Field(
        None, description='The id of the JobScheduled if the Payment was scheduled.'
    )
    sub_type: Optional[str] = Field(
        None,
        description='The sub-type of the Payment, can be PAYMENT, WITHDRAWAL, REVERSAL, REQUEST, BILLING, SCT, SDD or NLO.',
    )
    type: Optional[str] = Field(
        None,
        description='The type of Payment, can be BUNQ, EBA_SCT, EBA_SDD, IDEAL, SWIFT or FIS (card).',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the Payment was last updated (will be updated when chat messages are received).',
    )


class PaymentAutoAllocateInstance(BaseModel):
    created: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateInstance was created.',
    )
    error_message: Optional[List[Error]] = Field(
        None, description='The error message, if the payment auto allocating failed.'
    )
    id: Optional[int] = Field(
        None, description='The id of the PaymentAutoAllocateInstance.'
    )
    payment_auto_allocate_id: Optional[int] = Field(
        None,
        description='The ID of the payment auto allocate this instance belongs to.',
    )
    payment_batch: Optional[PaymentBatch] = Field(
        None, description='The payment batch allocating all the payments.'
    )
    payment_id: Optional[int] = Field(
        None,
        description='The ID of the payment that triggered the allocating of the payments.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the payment auto allocate instance. SUCCEEDED or FAILED.',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateInstance was last updated.',
    )


class PaymentAutoAllocateInstanceListing(BaseModel):
    created: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateInstance was created.',
    )
    error_message: Optional[List[Error]] = Field(
        None, description='The error message, if the payment auto allocating failed.'
    )
    id: Optional[int] = Field(
        None, description='The id of the PaymentAutoAllocateInstance.'
    )
    payment_auto_allocate_id: Optional[int] = Field(
        None,
        description='The ID of the payment auto allocate this instance belongs to.',
    )
    payment_batch: Optional[PaymentBatch] = Field(
        None, description='The payment batch allocating all the payments.'
    )
    payment_id: Optional[int] = Field(
        None,
        description='The ID of the payment that triggered the allocating of the payments.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the payment auto allocate instance. SUCCEEDED or FAILED.',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateInstance was last updated.',
    )


class PaymentAutoAllocateInstanceRead(BaseModel):
    created: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateInstance was created.',
    )
    error_message: Optional[List[Error]] = Field(
        None, description='The error message, if the payment auto allocating failed.'
    )
    id: Optional[int] = Field(
        None, description='The id of the PaymentAutoAllocateInstance.'
    )
    payment_auto_allocate_id: Optional[int] = Field(
        None,
        description='The ID of the payment auto allocate this instance belongs to.',
    )
    payment_batch: Optional[PaymentBatch] = Field(
        None, description='The payment batch allocating all the payments.'
    )
    payment_id: Optional[int] = Field(
        None,
        description='The ID of the payment that triggered the allocating of the payments.',
    )
    status: Optional[str] = Field(
        None,
        description='The status of the payment auto allocate instance. SUCCEEDED or FAILED.',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the PaymentAutoAllocateInstance was last updated.',
    )


class PaymentAutoAllocateListing(BaseModel):
    created: Optional[str] = Field(
        None, description='The timestamp when the PaymentAutoAllocate was created.'
    )
    id: Optional[int] = Field(None, description='The id of the PaymentAutoAllocate.')
    payment: Optional[Payment] = Field(
        None,
        description='The payment that was used to define the triggers for this payment auto allocate.',
    )
    status: Optional[str] = Field(None, description='The status.')
    trigger_amount: Optional[Amount] = Field(
        None,
        description='The amount on which this payment auto allocate will be triggered.',
    )
    type: Optional[str] = Field(None, description='The type.')
    updated: Optional[str] = Field(
        None, description='The timestamp when the PaymentAutoAllocate was last updated.'
    )


class PaymentAutoAllocateRead(BaseModel):
    created: Optional[str] = Field(
        None, description='The timestamp when the PaymentAutoAllocate was created.'
    )
    id: Optional[int] = Field(None, description='The id of the PaymentAutoAllocate.')
    payment: Optional[Payment] = Field(
        None,
        description='The payment that was used to define the triggers for this payment auto allocate.',
    )
    status: Optional[str] = Field(None, description='The status.')
    trigger_amount: Optional[Amount] = Field(
        None,
        description='The amount on which this payment auto allocate will be triggered.',
    )
    type: Optional[str] = Field(None, description='The type.')
    updated: Optional[str] = Field(
        None, description='The timestamp when the PaymentAutoAllocate was last updated.'
    )


class PaymentBatch(BaseModel):
    payments: Optional[PaymentBatchAnchoredPayment] = Field(
        None, description='The list of mutations that were made.'
    )


class PaymentBatchAnchoredPayment(BaseModel):
    Payment_1: Optional[List[Payment]] = Field(None, alias='Payment', description='')


class PaymentBatchListing(BaseModel):
    payments: Optional[PaymentBatchAnchoredPayment] = Field(
        None, description='The list of mutations that were made.'
    )


class PaymentBatchRead(BaseModel):
    payments: Optional[PaymentBatchAnchoredPayment] = Field(
        None, description='The list of mutations that were made.'
    )


class PaymentListing(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='A billing Address provided with the Payment, currently unused.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='A shipping Address provided with the Payment, currently unused.',
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    amount: Optional[Amount] = Field(
        None,
        description='The Amount transferred by the Payment. Will be negative for outgoing Payments and positive for incoming Payments (relative to the MonetaryAccount indicated by monetary_account_id).',
    )
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The Attachments attached to the Payment.'
    )
    balance_after_mutation: Optional[Amount] = Field(
        None, description='The new balance of the monetary account after the mutation.'
    )
    batch_id: Optional[int] = Field(
        None, description='The id of the PaymentBatch if this Payment was part of one.'
    )
    bunqto_expiry: Optional[str] = Field(
        None, description='When bunq.to payment is about to expire.'
    )
    bunqto_share_url: Optional[str] = Field(
        None, description='The status of the bunq.to payment.'
    )
    bunqto_status: Optional[str] = Field(
        None, description='The status of the bunq.to payment.'
    )
    bunqto_sub_status: Optional[str] = Field(
        None, description='The sub status of the bunq.to payment.'
    )
    bunqto_time_responded: Optional[str] = Field(
        None, description='The timestamp of when the bunq.to payment was responded to.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the Payment.',
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the Payment was done.'
    )
    description: Optional[str] = Field(
        None,
        description='The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.',
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The Geolocation where the Payment was done from.'
    )
    id: Optional[int] = Field(None, description='The id of the created Payment.')
    merchant_reference: Optional[str] = Field(
        None,
        description='Optional data included with the Payment specific to the merchant.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the MonetaryAccount the Payment was made to or from (depending on whether this is an incoming or outgoing Payment).',
    )
    payment_auto_allocate_instance: Optional[PaymentAutoAllocateInstance] = Field(
        None, description='A reference to the PaymentAutoAllocateInstance if it exists.'
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    scheduled_id: Optional[int] = Field(
        None, description='The id of the JobScheduled if the Payment was scheduled.'
    )
    sub_type: Optional[str] = Field(
        None,
        description='The sub-type of the Payment, can be PAYMENT, WITHDRAWAL, REVERSAL, REQUEST, BILLING, SCT, SDD or NLO.',
    )
    type: Optional[str] = Field(
        None,
        description='The type of Payment, can be BUNQ, EBA_SCT, EBA_SDD, IDEAL, SWIFT or FIS (card).',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the Payment was last updated (will be updated when chat messages are received).',
    )


class PaymentRead(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='A billing Address provided with the Payment, currently unused.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='A shipping Address provided with the Payment, currently unused.',
    )
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    amount: Optional[Amount] = Field(
        None,
        description='The Amount transferred by the Payment. Will be negative for outgoing Payments and positive for incoming Payments (relative to the MonetaryAccount indicated by monetary_account_id).',
    )
    attachment: Optional[List[AttachmentMonetaryAccountPayment]] = Field(
        None, description='The Attachments attached to the Payment.'
    )
    balance_after_mutation: Optional[Amount] = Field(
        None, description='The new balance of the monetary account after the mutation.'
    )
    batch_id: Optional[int] = Field(
        None, description='The id of the PaymentBatch if this Payment was part of one.'
    )
    bunqto_expiry: Optional[str] = Field(
        None, description='When bunq.to payment is about to expire.'
    )
    bunqto_share_url: Optional[str] = Field(
        None, description='The status of the bunq.to payment.'
    )
    bunqto_status: Optional[str] = Field(
        None, description='The status of the bunq.to payment.'
    )
    bunqto_sub_status: Optional[str] = Field(
        None, description='The sub status of the bunq.to payment.'
    )
    bunqto_time_responded: Optional[str] = Field(
        None, description='The timestamp of when the bunq.to payment was responded to.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount containing the public information of the other (counterparty) side of the Payment.',
    )
    created: Optional[str] = Field(
        None, description='The timestamp when the Payment was done.'
    )
    description: Optional[str] = Field(
        None,
        description='The description for the Payment. Maximum 140 characters for Payments to external IBANs, 9000 characters for Payments to only other bunq MonetaryAccounts.',
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The Geolocation where the Payment was done from.'
    )
    id: Optional[int] = Field(None, description='The id of the created Payment.')
    merchant_reference: Optional[str] = Field(
        None,
        description='Optional data included with the Payment specific to the merchant.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the MonetaryAccount the Payment was made to or from (depending on whether this is an incoming or outgoing Payment).',
    )
    payment_auto_allocate_instance: Optional[PaymentAutoAllocateInstance] = Field(
        None, description='A reference to the PaymentAutoAllocateInstance if it exists.'
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    scheduled_id: Optional[int] = Field(
        None, description='The id of the JobScheduled if the Payment was scheduled.'
    )
    sub_type: Optional[str] = Field(
        None,
        description='The sub-type of the Payment, can be PAYMENT, WITHDRAWAL, REVERSAL, REQUEST, BILLING, SCT, SDD or NLO.',
    )
    type: Optional[str] = Field(
        None,
        description='The type of Payment, can be BUNQ, EBA_SCT, EBA_SDD, IDEAL, SWIFT or FIS (card).',
    )
    updated: Optional[str] = Field(
        None,
        description='The timestamp when the Payment was last updated (will be updated when chat messages are received).',
    )


class RequestInquiry(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='The billing address provided by the accepting user if an address was requested.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='The shipping address provided by the accepting user if an address was requested.',
    )
    allow_amount_higher: Optional[bool] = Field(
        None,
        description='[DEPRECATED] Whether or not the accepting user can choose to accept with a higher amount than requested. Defaults to false.',
    )
    allow_amount_lower: Optional[bool] = Field(
        None,
        description='[DEPRECATED] Whether or not the accepting user can choose to accept with a lower amount than requested. Defaults to false.',
    )
    allow_bunqme: bool = Field(
        ..., description='Whether or not sending a bunq.me request is allowed.'
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested amount.')
    amount_responded: Optional[Amount] = Field(
        None, description='The responded amount.'
    )
    attachment: Optional[List[BunqId]] = Field(
        None, description='The attachments attached to the payment.'
    )
    batch_id: Optional[int] = Field(
        None, description='The id of the batch if the request was part of a batch.'
    )
    bunqme_share_url: Optional[str] = Field(
        None, description='The url that points to the bunq.me request.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount the money was requested from.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the payment request's creation."
    )
    description: Optional[str] = Field(
        None, description='The description of the inquiry.'
    )
    event_id: Optional[int] = Field(
        None,
        description="The ID of the associated event if the request was made using 'split the bill'.",
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The geolocation where the payment was done.'
    )
    id: Optional[int] = Field(None, description='The id of the created RequestInquiry.')
    merchant_reference: Optional[str] = Field(
        None,
        description="The client's custom reference that was attached to the request and the mutation.",
    )
    minimum_age: Optional[int] = Field(
        None,
        description='The minimum age the user accepting the RequestInquiry must have.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account the request response applies to.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to after accepting or rejecting the Request.',
    )
    reference_split_the_bill: Optional[RequestReferenceSplitTheBillAnchorObject] = (
        Field(
            None,
            description='The reference to the object used for split the bill. Can be Payment, PaymentBatch, ScheduleInstance, RequestResponse and MasterCardAction',
        )
    )
    require_address: Optional[str] = Field(
        None, description='Whether or not an address must be provided on accept.'
    )
    scheduled_id: Optional[int] = Field(
        None, description='The id of the scheduled job if the request was scheduled.'
    )
    status: Optional[str] = Field(None, description='The status of the request.')
    time_expiry: Optional[str] = Field(
        None, description='The timestamp of when the payment request expired.'
    )
    time_responded: Optional[str] = Field(
        None, description='The timestamp of when the payment request was responded to.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the payment request's last update."
    )
    user_alias_created: Optional[LabelUser] = Field(
        None,
        description="The label that's displayed to the counterparty with the mutation. Includes user.",
    )
    user_alias_revoked: Optional[LabelUser] = Field(
        None,
        description="The label that's displayed to the counterparty with the mutation. Includes user.",
    )
    want_tip: Optional[bool] = Field(
        None,
        description='[DEPRECATED] Whether or not the accepting user can give an extra tip on top of the requested Amount. Defaults to false.',
    )


class RequestInquiryBatch(BaseModel):
    event_id: Optional[int] = Field(
        None,
        description="The ID of the associated event if the request batch was made using 'split the bill'.",
    )
    reference_split_the_bill: Optional[RequestReferenceSplitTheBillAnchorObject] = (
        Field(
            None,
            description='The reference to the object used for split the bill. Can be Payment, PaymentBatch, ScheduleInstance, RequestResponse and MasterCardAction',
        )
    )
    request_inquiries: Optional[List[RequestInquiry]] = Field(
        None, description='The list of requests that were made.'
    )
    status: Optional[str] = Field(None, description='The status of the request.')
    total_amount_inquired: Optional[Amount] = Field(
        None, description='The total amount originally inquired for this batch.'
    )


class RequestInquiryBatchListing(BaseModel):
    reference_split_the_bill: Optional[RequestReferenceSplitTheBillAnchorObject] = (
        Field(
            None,
            description='The reference to the object used for split the bill. Can be Payment, PaymentBatch, ScheduleInstance, RequestResponse and MasterCardAction',
        )
    )
    request_inquiries: Optional[List[RequestInquiry]] = Field(
        None, description='The list of requests that were made.'
    )
    total_amount_inquired: Optional[Amount] = Field(
        None, description='The total amount originally inquired for this batch.'
    )


class RequestInquiryBatchRead(BaseModel):
    reference_split_the_bill: Optional[RequestReferenceSplitTheBillAnchorObject] = (
        Field(
            None,
            description='The reference to the object used for split the bill. Can be Payment, PaymentBatch, ScheduleInstance, RequestResponse and MasterCardAction',
        )
    )
    request_inquiries: Optional[List[RequestInquiry]] = Field(
        None, description='The list of requests that were made.'
    )
    total_amount_inquired: Optional[Amount] = Field(
        None, description='The total amount originally inquired for this batch.'
    )


class RequestInquiryListing(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='The billing address provided by the accepting user if an address was requested.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='The shipping address provided by the accepting user if an address was requested.',
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested amount.')
    amount_responded: Optional[Amount] = Field(
        None, description='The responded amount.'
    )
    attachment: Optional[List[BunqId]] = Field(
        None, description='The attachments attached to the payment.'
    )
    batch_id: Optional[int] = Field(
        None, description='The id of the batch if the request was part of a batch.'
    )
    bunqme_share_url: Optional[str] = Field(
        None, description='The url that points to the bunq.me request.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount the money was requested from.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the payment request's creation."
    )
    description: Optional[str] = Field(
        None, description='The description of the inquiry.'
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The geolocation where the payment was done.'
    )
    id: Optional[int] = Field(None, description='The id of the created RequestInquiry.')
    merchant_reference: Optional[str] = Field(
        None,
        description="The client's custom reference that was attached to the request and the mutation.",
    )
    minimum_age: Optional[int] = Field(
        None,
        description='The minimum age the user accepting the RequestInquiry must have.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account the request response applies to.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to after accepting or rejecting the Request.',
    )
    reference_split_the_bill: Optional[RequestReferenceSplitTheBillAnchorObject] = (
        Field(
            None,
            description='The reference to the object used for split the bill. Can be Payment, PaymentBatch, ScheduleInstance, RequestResponse and MasterCardAction',
        )
    )
    require_address: Optional[str] = Field(
        None, description='Whether or not an address must be provided on accept.'
    )
    scheduled_id: Optional[int] = Field(
        None, description='The id of the scheduled job if the request was scheduled.'
    )
    status: Optional[str] = Field(None, description='The status of the request.')
    time_expiry: Optional[str] = Field(
        None, description='The timestamp of when the payment request expired.'
    )
    time_responded: Optional[str] = Field(
        None, description='The timestamp of when the payment request was responded to.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the payment request's last update."
    )
    user_alias_created: Optional[LabelUser] = Field(
        None,
        description="The label that's displayed to the counterparty with the mutation. Includes user.",
    )
    user_alias_revoked: Optional[LabelUser] = Field(
        None,
        description="The label that's displayed to the counterparty with the mutation. Includes user.",
    )


class RequestInquiryRead(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='The billing address provided by the accepting user if an address was requested.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='The shipping address provided by the accepting user if an address was requested.',
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested amount.')
    amount_responded: Optional[Amount] = Field(
        None, description='The responded amount.'
    )
    attachment: Optional[List[BunqId]] = Field(
        None, description='The attachments attached to the payment.'
    )
    batch_id: Optional[int] = Field(
        None, description='The id of the batch if the request was part of a batch.'
    )
    bunqme_share_url: Optional[str] = Field(
        None, description='The url that points to the bunq.me request.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount the money was requested from.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the payment request's creation."
    )
    description: Optional[str] = Field(
        None, description='The description of the inquiry.'
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The geolocation where the payment was done.'
    )
    id: Optional[int] = Field(None, description='The id of the created RequestInquiry.')
    merchant_reference: Optional[str] = Field(
        None,
        description="The client's custom reference that was attached to the request and the mutation.",
    )
    minimum_age: Optional[int] = Field(
        None,
        description='The minimum age the user accepting the RequestInquiry must have.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account the request response applies to.',
    )
    redirect_url: Optional[str] = Field(
        None,
        description='The URL which the user is sent to after accepting or rejecting the Request.',
    )
    reference_split_the_bill: Optional[RequestReferenceSplitTheBillAnchorObject] = (
        Field(
            None,
            description='The reference to the object used for split the bill. Can be Payment, PaymentBatch, ScheduleInstance, RequestResponse and MasterCardAction',
        )
    )
    require_address: Optional[str] = Field(
        None, description='Whether or not an address must be provided on accept.'
    )
    scheduled_id: Optional[int] = Field(
        None, description='The id of the scheduled job if the request was scheduled.'
    )
    status: Optional[str] = Field(None, description='The status of the request.')
    time_expiry: Optional[str] = Field(
        None, description='The timestamp of when the payment request expired.'
    )
    time_responded: Optional[str] = Field(
        None, description='The timestamp of when the payment request was responded to.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the payment request's last update."
    )
    user_alias_created: Optional[LabelUser] = Field(
        None,
        description="The label that's displayed to the counterparty with the mutation. Includes user.",
    )
    user_alias_revoked: Optional[LabelUser] = Field(
        None,
        description="The label that's displayed to the counterparty with the mutation. Includes user.",
    )


class RequestInquiryUpdate(BaseModel):
    address_billing: Optional[Address] = Field(
        None,
        description='The billing address provided by the accepting user if an address was requested.',
    )
    address_shipping: Optional[Address] = Field(
        None,
        description='The shipping address provided by the accepting user if an address was requested.',
    )
    amount_inquired: Optional[Amount] = Field(None, description='The requested amount.')
    amount_responded: Optional[Amount] = Field(
        None, description='The responded amount.'
    )
    attachment: Optional[List[BunqId]] = Field(
        None, description='The attachments attached to the payment.'
    )
    batch_id: Optional[int] = Field(
        None, description='The id of the batch if the request was part of a batch.'
    )
    counterparty_alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description='The LabelMonetaryAccount with the public information of the MonetaryAccount the money was requested from.',
    )
    created: Optional[str] = Field(
        None, description="The timestamp of the payment request's creation."
    )
    description: Optional[str] = Field(
        None, description='The description of the inquiry.'
    )
    geolocation: Optional[Geolocation] = Field(
        None, description='The geolocation where the payment was done.'
    )
    id: Optional[int] = Field(None, description='The id of the payment request.')
    merchant_reference: Optional[str] = Field(
        None,
        description="The client's custom reference that was attached to the request and the mutation.",
    )
    minimum_age: Optional[int] = Field(
        None,
        description='The minimum age the user accepting the RequestInquiry must have.',
    )
    monetary_account_id: Optional[int] = Field(
        None,
        description='The id of the monetary account the request response applies to.',
    )
    reference_split_the_bill: Optional[RequestReferenceSplitTheBillAnchorObject] = (
        Field(
            None,
            description='The reference to the object used for split the bill. Can be Payment, PaymentBatch, ScheduleInstance, RequestResponse and MasterCardAction',
        )
    )
    require_address: Optional[str] = Field(
        None, description='Whether or not an address must be provided on accept.'
    )
    scheduled_id: Optional[int] = Field(
        None, description='The id of the scheduled job if the request was scheduled.'
    )
    status: Optional[str] = Field(None, description='The status of the request.')
    time_expiry: Optional[str] = Field(
        None, description='The timestamp of when the payment request expired.'
    )
    time_responded: Optional[str] = Field(
        None, description='The timestamp of when the payment request was responded to.'
    )
    updated: Optional[str] = Field(
        None, description="The timestamp of the payment request's last update."
    )
    user_alias_created: Optional[LabelUser] = Field(
        None,
        description="The label that's displayed to the counterparty with the mutation. Includes user.",
    )
    user_alias_revoked: Optional[LabelUser] = Field(
        None,
        description="The label that's displayed to the counterparty with the mutation. Includes user.",
    )


class RequestReferenceSplitTheBillAnchorObject(BaseModel):
    BillingInvoice: Optional[Invoice] = Field(None, description='')
    DraftPayment_1: Optional[DraftPayment] = Field(
        None, alias='DraftPayment', description=''
    )
    MasterCardAction_1: Optional[MasterCardAction] = Field(
        None, alias='MasterCardAction', description=''
    )
    Payment_1: Optional[Payment] = Field(None, alias='Payment', description='')
    PaymentBatch_1: Optional[PaymentBatch] = Field(
        None, alias='PaymentBatch', description=''
    )
    RequestResponse_1: Optional[RequestResponse] = Field(
        None, alias='RequestResponse', description=''
    )
    ScheduleInstance_1: Optional[ScheduleInstance] = Field(
        None, alias='ScheduleInstance', description=''
    )
    TransferwisePayment: Optional[TransferwiseTransfer] = Field(None, description='')
    WhitelistResult_1: Optional[WhitelistResult] = Field(
        None, alias='WhitelistResult', description=''
    )


class Schedule(BaseModel):
    object: Optional[ScheduleAnchorObject] = Field(
        None, description='The scheduled object. (Payment, PaymentBatch)'
    )
    recurrence_size: Optional[int] = Field(
        None,
        description='The schedule recurrence size. For example size 4 and unit WEEKLY means the recurrence is every 4 weeks.',
    )
    recurrence_unit: Optional[str] = Field(
        None,
        description='The schedule recurrence unit, options: ONCE, HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY',
    )
    status: Optional[str] = Field(
        None, description='The schedule status, options: ACTIVE, FINISHED, CANCELLED.'
    )
    time_end: Optional[str] = Field(None, description='The schedule end time (UTC).')
    time_start: Optional[str] = Field(
        None, description='The schedule start time (UTC).'
    )


class ScheduleAnchorObject(BaseModel):
    Payment_1: Optional[Payment] = Field(None, alias='Payment', description='')
    PaymentBatch_1: Optional[PaymentBatch] = Field(
        None, alias='PaymentBatch', description=''
    )


class ScheduleInstance(BaseModel):
    error_message: Optional[List[Error]] = Field(
        None,
        description='The message when the scheduled instance has run and failed due to user error.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    result_object: Optional[ScheduleInstanceAnchorObject] = Field(
        None,
        description='The result object of this schedule instance. (Payment, PaymentBatch)',
    )
    scheduled_object: Optional[ScheduleAnchorObject] = Field(
        None, description='The scheduled object. (Payment, PaymentBatch)'
    )
    state: Optional[str] = Field(
        None,
        description='The state of the scheduleInstance. (FINISHED_SUCCESSFULLY, RETRY, FAILED_USER_ERROR)',
    )
    time_end: Optional[str] = Field(None, description='The schedule end time (UTC).')
    time_start: Optional[str] = Field(
        None, description='The schedule start time (UTC).'
    )


class ScheduleInstanceAnchorObject(BaseModel):
    Payment_1: Optional[Payment] = Field(None, alias='Payment', description='')
    PaymentBatch_1: Optional[PaymentBatch] = Field(
        None, alias='PaymentBatch', description=''
    )


class ScheduleInstanceListing(BaseModel):
    error_message: Optional[List[Error]] = Field(
        None,
        description='The message when the scheduled instance has run and failed due to user error.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    result_object: Optional[ScheduleInstanceAnchorObject] = Field(
        None,
        description='The result object of this schedule instance. (Payment, PaymentBatch)',
    )
    scheduled_object: Optional[ScheduleAnchorObject] = Field(
        None, description='The scheduled object. (Payment, PaymentBatch)'
    )
    state: Optional[str] = Field(
        None,
        description='The state of the scheduleInstance. (FINISHED_SUCCESSFULLY, RETRY, FAILED_USER_ERROR)',
    )
    time_end: Optional[str] = Field(None, description='The schedule end time (UTC).')
    time_start: Optional[str] = Field(
        None, description='The schedule start time (UTC).'
    )


class ScheduleInstanceRead(BaseModel):
    error_message: Optional[List[Error]] = Field(
        None,
        description='The message when the scheduled instance has run and failed due to user error.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    result_object: Optional[ScheduleInstanceAnchorObject] = Field(
        None,
        description='The result object of this schedule instance. (Payment, PaymentBatch)',
    )
    scheduled_object: Optional[ScheduleAnchorObject] = Field(
        None, description='The scheduled object. (Payment, PaymentBatch)'
    )
    state: Optional[str] = Field(
        None,
        description='The state of the scheduleInstance. (FINISHED_SUCCESSFULLY, RETRY, FAILED_USER_ERROR)',
    )
    time_end: Optional[str] = Field(None, description='The schedule end time (UTC).')
    time_start: Optional[str] = Field(
        None, description='The schedule start time (UTC).'
    )


class ScheduleListing(BaseModel):
    object: Optional[ScheduleAnchorObject] = Field(
        None, description='The scheduled object. (Payment, PaymentBatch)'
    )
    recurrence_size: Optional[int] = Field(
        None,
        description='The schedule recurrence size. For example size 4 and unit WEEKLY means the recurrence is every 4 weeks.',
    )
    recurrence_unit: Optional[str] = Field(
        None,
        description='The schedule recurrence unit, options: ONCE, HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY',
    )
    status: Optional[str] = Field(
        None, description='The schedule status, options: ACTIVE, FINISHED, CANCELLED.'
    )
    time_end: Optional[str] = Field(None, description='The schedule end time (UTC).')
    time_start: Optional[str] = Field(
        None, description='The schedule start time (UTC).'
    )


class SchedulePayment(BaseModel):
    payment: Optional[SchedulePaymentEntry] = Field(
        None, description='The payment details.'
    )
    schedule: Optional[Schedule] = Field(None, description='The schedule details.')
    status: Optional[str] = Field(
        None, description='The schedule status, options: ACTIVE, FINISHED, CANCELLED.'
    )


class SchedulePaymentBatch(BaseModel):
    payments: Optional[List[SchedulePaymentEntry]] = Field(
        None, description='The payment details.'
    )
    schedule: Optional[Schedule] = Field(None, description='The schedule details.')


class SchedulePaymentBatchRead(BaseModel):
    payments: Optional[List[SchedulePaymentEntry]] = Field(
        None, description='The payment details.'
    )
    schedule: Optional[Schedule] = Field(None, description='The schedule details.')


class SchedulePaymentListing(BaseModel):
    payment: Optional[SchedulePaymentEntry] = Field(
        None, description='The payment details.'
    )
    schedule: Optional[Schedule] = Field(None, description='The schedule details.')
    status: Optional[str] = Field(
        None, description='The schedule status, options: ACTIVE, FINISHED, CANCELLED.'
    )


class SchedulePaymentRead(BaseModel):
    payment: Optional[SchedulePaymentEntry] = Field(
        None, description='The payment details.'
    )
    schedule: Optional[Schedule] = Field(None, description='The schedule details.')
    status: Optional[str] = Field(
        None, description='The schedule status, options: ACTIVE, FINISHED, CANCELLED.'
    )


class ScheduleRead(BaseModel):
    object: Optional[ScheduleAnchorObject] = Field(
        None, description='The scheduled object. (Payment, PaymentBatch)'
    )
    recurrence_size: Optional[int] = Field(
        None,
        description='The schedule recurrence size. For example size 4 and unit WEEKLY means the recurrence is every 4 weeks.',
    )
    recurrence_unit: Optional[str] = Field(
        None,
        description='The schedule recurrence unit, options: ONCE, HOURLY, DAILY, WEEKLY, MONTHLY, YEARLY',
    )
    status: Optional[str] = Field(
        None, description='The schedule status, options: ACTIVE, FINISHED, CANCELLED.'
    )
    time_end: Optional[str] = Field(None, description='The schedule end time (UTC).')
    time_start: Optional[str] = Field(
        None, description='The schedule start time (UTC).'
    )


class TranslinkTransaction(BaseModel):
    description: str = Field(..., description='Description of the payment request.')
    payments: List[Payment] = Field(
        ..., description='The list of payments we want to send in a single transaction.'
    )
    reference: str = Field(..., description='The request reference.')
    type: str = Field(
        ...,
        description='Type of transaction, can be TRIP, REFUND, WITHDRAWAL or TOP_UP.',
    )


class TranslinkTransactionListing(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    amount: Optional[Amount] = Field(
        None, description='The total amount of the transaction.'
    )
    description: Optional[str] = Field(
        None, description='Description of the payment request.'
    )
    entries: Optional[List[TranslinkTransactionEntry]] = Field(
        None, description='The list of entries in the transaction.'
    )
    failure_reason: Optional[List[Error]] = Field(
        None, description='The reason why the transaction FAILED processing.'
    )
    payments: Optional[PaymentBatchAnchoredPayment] = Field(
        None, description='The list of mutations that were made.'
    )
    reference: Optional[str] = Field(None, description='The request reference.')
    status: Optional[str] = Field(
        None,
        description='The status of the transaction. Can be CREATED, SETTLED or FAILED.',
    )
    type: Optional[str] = Field(
        None,
        description='Type of transaction, can be TRIP, REFUND, WITHDRAWAL or TOP_UP.',
    )


class TranslinkTransactionRead(BaseModel):
    alias: Optional[LabelMonetaryAccount] = Field(
        None,
        description="The LabelMonetaryAccount containing the public information of 'this' (party) side of the Payment.",
    )
    amount: Optional[Amount] = Field(
        None, description='The total amount of the transaction.'
    )
    description: Optional[str] = Field(
        None, description='Description of the payment request.'
    )
    entries: Optional[List[TranslinkTransactionEntry]] = Field(
        None, description='The list of entries in the transaction.'
    )
    failure_reason: Optional[List[Error]] = Field(
        None, description='The reason why the transaction FAILED processing.'
    )
    payments: Optional[PaymentBatchAnchoredPayment] = Field(
        None, description='The list of mutations that were made.'
    )
    reference: Optional[str] = Field(None, description='The request reference.')
    status: Optional[str] = Field(
        None,
        description='The status of the transaction. Can be CREATED, SETTLED or FAILED.',
    )
    type: Optional[str] = Field(
        None,
        description='Type of transaction, can be TRIP, REFUND, WITHDRAWAL or TOP_UP.',
    )


class WhitelistResult(BaseModel):
    error_message: Optional[List[Error]] = Field(
        None,
        description='The message when the whitelist result has failed due to user error.',
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    monetary_account_paying_id: Optional[int] = Field(
        None,
        description='The account from which payments will be deducted when a transaction is matched with this whitelist.',
    )
    object: Optional[WhitelistResultViewAnchoredObject] = Field(
        None,
        description='The details of the external object the event was created for.',
    )
    request_reference_split_the_bill: Optional[List[RequestInquiryReference]] = Field(
        None,
        description='The reference to the object used for split the bill. Can be RequestInquiry or RequestInquiryBatch',
    )
    status: Optional[str] = Field(
        None, description='The status of the WhitelistResult.'
    )
    sub_status: Optional[str] = Field(
        None, description='The subStatus of the WhitelistResult.'
    )
    whitelist: Optional[Whitelist] = Field(
        None, description='The corresponding whitelist.'
    )


class WhitelistResultViewAnchoredObject(BaseModel):
    draftPayment: Optional[DraftPayment] = Field(
        None, description='The DraftPayment object'
    )
    id: Optional[int] = Field(None, description='The ID of the whitelist entry.')
    requestResponse: Optional[RequestResponse] = Field(
        None, description='The RequestResponse object'
    )


class UserUserIDEventGetResponse(RootModel[List[EventListing]]):
    root: List[EventListing]


class UserUserIDInsightsSearchGetResponse(RootModel[List[InsightEventListing]]):
    root: List[InsightEventListing]


class UserUserIDMonetaryAccountMonetaryAccountIDBunqmeTabGetResponse(
    RootModel[List[BunqMeTabListing]]
):
    root: List[BunqMeTabListing]


class UserUserIDMonetaryAccountMonetaryAccountIDCurrencyConversionGetResponse(
    RootModel[List[CurrencyConversionListing]]
):
    root: List[CurrencyConversionListing]


class UserUserIDMonetaryAccountMonetaryAccountIDDraftPaymentGetResponse(
    RootModel[List[DraftPaymentListing]]
):
    root: List[DraftPaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentGetResponse(
    RootModel[List[PaymentListing]]
):
    root: List[PaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocateGetResponse(
    RootModel[List[PaymentAutoAllocateListing]]
):
    root: List[PaymentAutoAllocateListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentAutoAllocatePaymentAutoAllocateIDInstanceGetResponse(
    RootModel[List[PaymentAutoAllocateInstanceListing]]
):
    root: List[PaymentAutoAllocateInstanceListing]


class UserUserIDMonetaryAccountMonetaryAccountIDPaymentBatchGetResponse(
    RootModel[List[PaymentBatchListing]]
):
    root: List[PaymentBatchListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryGetResponse(
    RootModel[List[RequestInquiryListing]]
):
    root: List[RequestInquiryListing]


class UserUserIDMonetaryAccountMonetaryAccountIDRequestInquiryBatchGetResponse(
    RootModel[List[RequestInquiryBatchListing]]
):
    root: List[RequestInquiryBatchListing]


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleGetResponse(
    RootModel[List[ScheduleListing]]
):
    root: List[ScheduleListing]


class UserUserIDMonetaryAccountMonetaryAccountIDSchedulePaymentGetResponse(
    RootModel[List[SchedulePaymentListing]]
):
    root: List[SchedulePaymentListing]


class UserUserIDMonetaryAccountMonetaryAccountIDScheduleScheduleIDScheduleInstanceGetResponse(
    RootModel[List[ScheduleInstanceListing]]
):
    root: List[ScheduleInstanceListing]


class UserUserIDMonetaryAccountMonetaryAccountIDTranslinkTransactionGetResponse(
    RootModel[List[TranslinkTransactionListing]]
):
    root: List[TranslinkTransactionListing]


NotificationFilterEmail.model_rebuild()
NotificationFilterPush.model_rebuild()
NotificationFilterUrl.model_rebuild()
BankSwitchServiceNetherlandsIncomingPayment.model_rebuild()
BankSwitchServiceNetherlandsIncomingPaymentRead.model_rebuild()
BunqMeFundraiserResult.model_rebuild()
BunqMeFundraiserResultRead.model_rebuild()
BunqMeTabListing.model_rebuild()
BunqMeTabRead.model_rebuild()
BunqMeTabResultInquiry.model_rebuild()
BunqMeTabResultResponse.model_rebuild()
BunqMeTabResultResponseRead.model_rebuild()
CurrencyConversionListing.model_rebuild()
CurrencyConversionRead.model_rebuild()
DraftPayment.model_rebuild()
DraftPaymentAnchorObject.model_rebuild()
DraftPaymentListing.model_rebuild()
DraftPaymentRead.model_rebuild()
EventListing.model_rebuild()
EventObject.model_rebuild()
Payment.model_rebuild()
PaymentAutoAllocateInstance.model_rebuild()
PaymentAutoAllocateInstanceListing.model_rebuild()
PaymentAutoAllocateInstanceRead.model_rebuild()
PaymentBatch.model_rebuild()
RequestInquiry.model_rebuild()
RequestInquiryBatch.model_rebuild()
RequestInquiryBatchListing.model_rebuild()
RequestInquiryBatchRead.model_rebuild()
RequestInquiryListing.model_rebuild()
RequestInquiryRead.model_rebuild()
RequestInquiryUpdate.model_rebuild()
RequestReferenceSplitTheBillAnchorObject.model_rebuild()
Schedule.model_rebuild()
ScheduleInstance.model_rebuild()
WhitelistResult.model_rebuild()
